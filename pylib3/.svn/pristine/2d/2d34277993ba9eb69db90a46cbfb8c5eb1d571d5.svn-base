#{{{ Documentation and module imports
"""
Date: 15.08.2012
Author: Christian Drews <drews@physik.uni-kiel.de>, Lars Berger <berger@physik.uni-kiel.de>

KNOWN BUGS: #1 Memory leak if you call plot routine too often. Memory is not released. Matplotlib sucks
"""
import sys, os
from copy import deepcopy
from numpy import array,histogram, sum,zeros,argmin,linspace,transpose,where,sqrt,exp, arange, max, min, nonzero, cos, sin, mean,std, isnan,isinf,inf, ones,NAN, histogram2d, ndarray,average,alltrue,ones,greater_equal,equal,greater,less_equal,less,not_equal,logical_or,iterable,unique
import matplotlib
import pylab
from pylib.etMisc import loading_bar
import cPickle
import pdb
#}}}



def ArgParser(func):
	def funcDEC(self,*args,**kwargs):
		tmp = list(args)
		if isinstance(args[0],str) and args[0].lower()=="all":
			tmp[0]=self.mask.keys()
			tmp[0].remove("Master")
			func(self,*tuple(tmp),**kwargs)
		elif isinstance(args[0],str):
			tmp[0]=[args[0]]
			func(self,*tuple(tmp),**kwargs)
		elif iterable(args[0]):
			func(self,*args,**kwargs)
		else:
			print "Invalid Arguments - Function call canceled!"	
	return funcDEC
class plot_mod(object):
	def __init__(self,pylabfig,style="STD"):
		"""
		Init the plot modifier. This class is used to give the user a backend to modifiy plot created with
		dbData
		"""
		self.fig = pylabfig
		self.style = style
		self.oldobj = self._process_fig()
	def _process_fig(self):
		self.axes = {}
		self.texts = {}
		self.lines = {}
		self.linelabels={}
		self.objects = {}
		for a,axes in enumerate(self.fig.axes):
			self.axes["A%i"%a]=axes
			self.objects["A%i"%a]={}
			self.texts["A%i"%a]={}
			self.lines["A%i"%a]={}
		for a, axes in enumerate(self.axes):
			for t,text in enumerate(self.axes[axes].texts):
				self.objects[axes]["T%i"%t]=text
				self.texts[axes]["T%i"%t]=text
		for a, axes in enumerate(self.axes):
			lines=self.axes[axes].lines
			for l,line in enumerate(lines):
				self.objects[axes]["L%i"%l]=line
				self.lines[axes]["L%i"%l]=line
		return self.objects
	def get_axis(self,keya):
		"""
		Return the choses axis. 
		INPUT: keyword of the axis (Can be looked up with self.show_axes)
		"""
		if self.axes.has_key(keya):
			return self.axes[keya]
		else:
			print "Can't find axis '%s'"%(keya)
	def get_object(self,keya,keyo):
		"""
		Return the choses object. 
		INPUT: keya: keyword of the axis (Can be looked up with self.show_axes)
		keyt: keyword of the object (Can be looked up with self.show_axes)
		"""
		if self.objects.has_key(keya):
			if self.objects[keya].has_key(keyo):
				return self.objects[keya][keyo]
			else:
				print "Can't find object %s in axis '%s'"%(keyt,keyo)
		else:
			print "Can't find axis '%s'"%(keya)
	def del_object(self,keya,keyo):
		"""
		Return the choses object. 
		INPUT: keya: keyword of the axis (Can be looked up with self.show_axes)
		keyt: keyword of the object (Can be looked up with self.show_axes)
		"""
		self.get_obj(keya,keyo).remove()
		self._process_fig()
	def set_fontsize(self,size):
		"""
		Set all labels to the given fontsize	
		"""
		matplotlib.rcParams.update({'font.size': size})
	def show_axes(self):
		"""
		This routine shows all available axes with all printed labels in it.
		"""
		self._process_fig()
		print "Available Axes to modify on plot %s:"%(self.style)
		print "|"
		for keya in sorted(self.axes.keys()):
			print "Axis %s:"%(keya)
			print "---------"
			print "   | Labels"
			for keyt in sorted(self.texts[keya].keys()):
				text = self.objects[keya][keyt].get_text()
				print "   ----> %s: '%s'"%(keyt,text)
			print "   | Lines"
			for keyl in sorted(self.lines[keya].keys()):
				linec = self.objects[keya][keyl].get_color()
				lineds = self.objects[keya][keyl].get_drawstyle()
				linels = self.objects[keya][keyl].get_linestyle()
				print "   ----> %s: ls='%s', ds='%s', c='%s'"%(keyl,linels,lineds,linec)
	def set_line(self,*arg,**kwarg):
		"""
		This routine plots lines onto the given axes. It is used just like the normal 
		matplotlib plot command.
		INPUT: arg and kwarg can be the same arguments you would give to pylab.plot
		kwarg may contain one additional keyword 'axes', 
		which may be a list axes keys or an axis key string. If this keyword is not given,
		lineplot is performed on all axis
		"""
		if kwarg.has_key("axes"):
			if isinstance(kwarg["axes"],str):
				Axes=[kwarg["axes"]]
			else:
				Axes=kwarg["axes"]
			kwarg.pop("axes")
		else:
			Axes=self.axes.keys()
		for A in Axes:
			xl=self.axes[A].get_xlim()
			yl=self.axes[A].get_ylim()
			self.axes[A].plot(*arg,**kwarg)
			self.axes[A].set_xlim(xl)
			self.axes[A].set_ylim(yl)
		self.update()
	def set_text(self,*arg,**kwarg):
		"""
		This routine plots text onto the given axes. It is used just like the normal 
		matplotlib text command.
		INPUT: arg and kwarg can be the same arguments you would give to pylab.plot
		kwarg may contain one additional keyword 'axes', 
		which may be a list axes keys or an axis key string. If this keyword is not given,
		lineplot is performed on all axis
		"""
		if kwarg.has_key("axes"):
			if isinstance(kwarg["axes"],str):
				Axes=[kwarg["axes"]]
			else:
				Axes=kwarg["axes"]
			kwarg.pop("axes")
		else:
			Axes=self.axes.keys()
		for A in Axes:
			self.axes[A].text(*arg,**kwarg)
		self.update()
	def reset(self):
		"""
		This method resets the whole figure to its original state 
		"""
		for ax in self.axes:
			for o in self.objects[ax]:
				if not self.objects[ax][o] in self.oldobj[ax].values(): self.del_object(ax,o)
		self._process_fig()
		self.update()
	def update(self):
		"""
		Updates the plot
		"""
		self.fig.show()
class plot_properties(object):
	def __init__(self,prod):
		self.props = {}
		self.props["color"]="red"
		self.props["name"]=prod
		self.props["linewidth"]=1
		self.props["linestyle"]='-'
		self.props["marker"]='None'
		self.props["markersize"]=1
		self.props["contourcolor"]="jet"
		self.props["label_loc"]=(0.05,0.05)
	def set_name(self,name):
		self.name=name
	def set(self,prop,val):
		if self.props.has_key(prop):
			self.props[prop]=val
		else:
			print "Property %s not available!"%(prop)
	def get_all(self):
		return self.props
	def get(self,prop):
		if self.props.has_key(prop):
			return self.props[prop]
		else:
			return False
	def get_name(self):
		return self.name
	def get_hist1d(self):
		tmp = deepcopy(self.props)
		if tmp.has_key("name"): tmp.pop("name")
		tmp["drawstyle"]="steps"
		print tmp
		return tmp
class submask(object):
	def __init__(self,key,op,*arg):
		self.key = key
		self.operator = op
		self.arg = arg
	def calc(self,data):
		if isinstance(data,ndarray):
			return self.get_operator()(data,*self.arg)
		else:
			return self.get_operator()(*self.arg)
	def get_operator(self):
		if isinstance(self.operator,str):
			if self.operator.lower() in [">=","ge"]:
				return greater_equal
			if self.operator.lower() in [">","gt"]:
				return greater
			if self.operator.lower() in ["==","eq"]:
				return self._eq
			if self.operator.lower() in ["<=","le"]:
				return less_equal
			if self.operator.lower() in ["<","lt"]:
				return less
			if self.operator.lower() in ["!=","ne"]:
				return not_equal
			if self.operator.lower() in ["><","bn"]:
				return self._bn
			if self.operator.lower() in [">=<","be"]:
				return self._be
		else:
			return self.operator
	def _eq(self,data,arg1):
		return data==arg1
	def _bn(self,data,arg1,arg2):
		return greater(data,arg1)*less(data,arg2)
	def _be(self,data,arg1,arg2):
		return greater_equal(data,arg1)*less_equal(data,arg2)
	def get_range(self):
		if self.operator in [">=","ge"]:
			return self.arg[0],None,True,False,False
		if self.operator in [">","gt"]:
			return self.arg[0],None,False,False,False
		if self.operator in ["==","eq"]:
			return self.arg[0],None,False,False,True
		if self.operator in ["<=","le"]:
			return None,self.arg[0],False,True,False
		if self.operator in ["<","lt"]:
			return None,self.arg[0],False, False,False
		if self.operator in ["><","bn"]:
			return self.arg[0],self.arg[1],False, False,False
		if self.operator in [">=<","be"]:
			return self.arg[0],self.arg[1],True, True,False
		else:
			return None,None,False,False,False
class mask(object):
	def __init__(self,data,name="Default"):
		self.data = data
		self.ma = ones(self.data[self.data.keys()[0]].shape[0],dtype=bool)
		self.submasks = {}
	def add_submask(self,key,operator,*arg,**kwarg):
		if kwarg.has_key("reset") and kwarg["reset"]==True:
			self.remove_submask(key)
		if not self.data.has_key(key) and "MASK2D" not in key:
			print "add_submask : Invalid Data Product (wrong key)"
			return False
		if self.submasks.has_key(key):
			self.submasks[key].append(submask(key,operator,*arg))
		else:
			self.submasks[key]=[submask(key,operator,*arg)]
		self.calc_mask()
	def remove_submask(self,key,N=False):
		if key!='all' and N==False:
			self.submasks.pop(key,False)
		elif key!='all':
			self.submasks[key].pop(N)
		else:
			self.submasks={}
		self.calc_mask()
	def calc_mask(self):
		self.ma = ones(self.data[self.data.keys()[0]].shape[0],dtype=bool)
		for key in self.submasks:
			tmp_ma = zeros(self.ma.shape[0],dtype=bool)
			for subm in self.submasks[key]:
				if key in self.data.keys(): #If key is found in self.data, pass data prod to calc
					tmp_ma = logical_or(tmp_ma,subm.calc(self.data[key]))
				else: # If key not found, pass False (for user defined functions)
					tmp_ma = logical_or(tmp_ma,subm.calc(False))
			self.ma*=tmp_ma
	def calc_submask(self,prod):
		if self.submasks.has_key(prod):
			tmp_ma = zeros(self.ma.shape[0],dtype=bool)
			for subm in self.submasks[prod]:
				tmp_ma = logical_or(tmp_ma,subm.calc(self.data[prod]))
			return tmp_ma
		else:
			return zeros(self.ma.shape[0],dtype=bool)
	def cleanup_mask(self):
		nkeys=self.data.keys()
		okeys=self.submasks.keys()
		for sm in okeys:
			if not sm in nkeys:
				self.submasks.pop(sm)
	def update_mask(self):
		self.cleanup_mask()
		self.calc_mask()
	def get(self):
		return self.ma
	def set(self,ma):
		self.ma=ma
class mask2D(object):
	def __init__(self,dbData,mask,prodx,prody):
		"""
		INPUT ###
		dbData: instance of dbData
		prodx: xval for the 2D mask
		prody: yval for the 2D mask
		"""
		self.db = dbData
		self.mask = mask
		self.prodx = prodx
		self.prody = prody
		self.pX = self.db.data[self.prodx]
		self.pY = self.db.data[self.prody]
		self.M2D = []
		self.state = "NOT APPLIED"
	def _draw(self):
		for patch in self.P.fig.gca().patches: patch.remove()
		self.P.fig.gca().add_patch(matplotlib.patches.Polygon(self.M2D,facecolor="red",alpha=0.5,fill=True))
		self.P.update()

	def _enter(self,event):
		xd,yd = event.xdata,event.ydata
		if event.key=="enter":
			print "Processing Filter %s/%s on mask %s - Please Wait"%(self.prodx,self.prody,self.mask)
			self.db.set_mask(self.mask,"MASK2D %s/%s"%(self.prodx,self.prody),self.pX,self.pY,op=self.get_op())
			print "Processing finished - Filter applied!"
			self.P.fig.gca().set_title("Mask2D of '%s'/'%s' on mask '%s' (Applied)"%(self.prodx,self.prody,self.mask),backgroundcolor="green")
			self.P.fig.canvas.mpl_disconnect(self.C2)
			self.P.update()
			self.state="APPLIED"
		elif event.key=="a":
			self.M2D.append((xd,yd))
			self._draw()
		elif event.key=="r":
			self.M2D.pop()
			self._draw()
		elif event.key=="c":
			self.P.fig.canvas.mpl_disconnect(self.C2)
			self.P.update()
		else:
			pass
	def create_mask2D(self,**kwargs):
		"""
		Thos routine takes the same **kwargs as hist2d from dbData class
		"""
		self.P = self.db.hist2d(self.prodx,self.prody,smask=[self.mask],**kwargs)
		self.P.fig.gca().set_title("Mask2D of '%s'/'%s' on mask '%s' (NOT APPLIED)"%(self.prodx,self.prody,self.mask),backgroundcolor="red")
		self.C2=self.P.fig.canvas.mpl_connect('key_press_event',lambda event: self._enter(event))
	def _compute(self,pX,pY):
		"""
		This returns the current 2D mask
		"""
		return matplotlib.nxutils.points_inside_poly(array((pX,pY)).T,self.M2D)
	def get_op(self):
		"""
		This routine returns the operator used for the set_mask_routine
		"""
		def op(*arg,**kwarg):
			return self._compute(arg[0],arg[1])
		return op
class dbData(object):
	def __init__(self,*args,**kwargs):
		self.mask = {}
		self.data ={}
		self.dp ={}
		self.mp ={}
		self.load_data(*args,**kwargs)
		for key in self.data:
			self.data[key]=array(self.data[key])
		if self.data:
			self.add_mask("Master")
		else:
			print "Implement load_data method first!"
			exit()
		self._init_plot_properties()
	def _init_plot_properties(self):
		"""
		Initialize Plot properties
		"""
		for i,key in enumerate(sorted(self.data.keys())):
			self.dp[key] = plot_properties(key)
			self.dp[key].set("color",self._get_color(i))
		for i,key in enumerate(sorted(self.mask.keys())):
			self.mp[key] = plot_properties(key)
			self.mp[key].set("color",self._get_color(i))
	def _get_color(self,i):
		colors = ["red","blue","green","orange","coral","navy","darkgoldenrod","DarkRed","Fuchsia","Maroon","pink","OrangeRed","Olive","Indigo","Firebrick","DimGray","Purple","Plum","PaleGreen","brown","DarkBlue"]*10
		return colors[i-1]
	def get_data(self,mask,prod):
		"""
		Returns an array of prods of a given mask. Note that the Master mask is also applied!
		INPUT: prod - Data product you want to get (a string)
		mask - applied mask for which you get your data product (a string)
		"""
		return self.data[prod][self.mask[mask].get()*self.DM()]
	def get_mask(self,mask):
		"""
		Returns an the current mask. Note that the Master mask is also applied!
		INPUT: 
		mask - mask you want to get (a string)
		"""
		return self.mask[mask].get()*self.DM()
	def DM(self):
		""" Returns the Master Mask"""
		return self.mask["Master"].get()
	def set_data_property(self,prod,prop,val):
		"""
		Assigns plot properties to the respective data products 
		"""
		if prod=="all":
			prods = self.data.keys()
		else:
			prods = [prod]
		for prod in prods:
			self.dp[prod].set(prop,val)
	def set_mask_property(self,mask,prop,val):
		"""
		Assigns plot properties to the respective masks
		"""
		if mask=="all":
			masks = self.mask.keys()
			masks.remove("Master")
		else:
			masks = [mask]
		for mask in masks:
			self.mp[mask].set(prop,val)
	def set_global_property(self,prop,val):
		"""
		This Changes global properties of the plot. Here you can change the fontsize 
		of all labels for instance. 
		"""
		try:
			matplotlib.rcParams[prop]=val
		except:
			for key in sorted(matplotlib.rcParams.keys()):
				print key,": ",matplotlib.rcParams[key]
			print ""
			print "################## !!! ERROR !!! #######################"
			print "Wrong Property used. See the list above for all possible properties and currently set values"
	@ArgParser
	def add_mask(self,name):
		"""
		This routine adds a (or a list of) new mask(s) to the total 
		INPUT : name --> (list of) str that specifies the added masks ; This argument will converted by self._get_namelist
		"""
		for key in name:
			if not key in self.mask.keys():
				self.mask[key] = mask(self.data)
				self.mp[key] = plot_properties(key)
				self.mp[key].set("color",self._get_color(len(self.mask)-1))
			else:
				print "Mask ",key," already exists, no action performed"
	def add_data(self,key,data):
		"""
		This method adds an additional dataproduct to self.data with keyword 'key'
		"""
		if not key in self.data.keys():
			if len(self.data[self.data.keys()[0]])==len(data):
				self.data[key]=data
				self.dp[key]=plot_properties(key)
				self.dp[key].set("color",self._get_color(len(self.data)-1))
			else:
				print "Supplied data has not the same length (%s) as entries in self.data (%s)"%(len(data),len(self.data[self.data.keys()[0]]))
		else:
			print "Keyword '%s' already exists!"%(key)
			if raw_input("Proceed? [Y/N]").lower() in ["yes","y","jo","ja","j"]:
				print "You have to add data to all keys to maintain a valid data class."
				if raw_input(" Do you really really want to do this? [Y/N]").lower() in ["yes","y","jo","ja","j"]:
					self.data[key]=append(self.data[key],data)
				else:
					print "That is really very sensible of you. Thanks you for not endangering my structure."
			else:
				print "That is very sensible of you. Thank you for not endangering my structure."
	def copy_mask(self,nmask,omask):
		"""
		Copies mask 'osmask' into new mask 'nmask'
		"""
		self.mask[nmask]=deepcopy(self.mask[omask])
		self.mp[nmask] = plot_properties(nmask)
		self.mp[nmask].set("color",self._get_color(len(self.mask)-1))
	@ArgParser
	def remove_mask(self,name):
		"""
		This routine removes specified masks. Beware Master mask must not and cannot be removed!
		INPUT : name --> (list of) str that specifies the remnoved masks ; This argument will converted by self._get_namelist
		"""
		if "Master" in name:
			print "Master mask must not be removed!"
			masks.remove("Master")
		for mask in name:
			self.mask.pop(mask)
			self.mp.pop(mask)
	@ArgParser
	def remove_submask(self,name,subname):
		"""
		This routine removes specified submask of masks.
		INPUT : name --> (list of) str that specifies the masks on which submask will be removed
		subname --> name of the submask to be removed
		"""
		for mask in name:
			self.mask[mask].remove_submask(subname)
	@ArgParser
	def reset_mask(self,name):
		"""
		This routine removes specified masks.
		INPUT : name --> (list of) str that specifies the remnoved masks ; This argument will converted by self._get_namelist
		"""
		for mask in name:
			self.mask[mask].remove_submask('all') 
	def show_mask(self,smask=False,cmask="Master"):
		"""
		This routine shows the current set masks
		"""
		self.pylabsm = pylab.figure()
		if smask==False:
			masks = self.mask.keys()
		else:
			masks = smask
		Nmasks = len(masks)
		ph = 0.8/Nmasks #Panel height
		maxNprods=1
		for key in masks:
			N=len(self.mask[key].submasks.keys())
			if N>maxNprods:
				maxNprods=N
		for kindex,key in enumerate(masks):
			Nmask = sum(self.mask[key].get()*self.DM())
			ax = pylab.axes([0.1,0.1+kindex*ph,0.6,ph])
			ax2 = pylab.axes([0.7,0.1+kindex*ph,0.2,ph])
			ax.set_ylabel("%s"%self.mp[key].get("name"),backgroundcolor=self.mp[key].get("color"),color="white")
			for i in ["bottom","top","left","right"]: 
				ax.spines[i].set_linewidth(3)
				ax2.spines[i].set_linewidth(3)
				ax.spines[i].set_zorder(50)
			M = self.mask[key]
			prods = M.submasks.keys()
			Nprods = len(prods) 
			dh = .5/maxNprods #Bar Height
			ypos=linspace(0.,1.,Nprods+2)[1:-1]+dh/2.
			for pindex,prod in enumerate(prods):
				if cmask==False and "MASK2D" not in prod:
					cdata = self.data[prod]
					Nevents = len(self.data[prod])
				elif "MASK2D" not in prod:
					if key!="Master":
						cdata = self.data[prod][self.mask[cmask].get()]
						Nevents = sum(self.mask[cmask].get())
					else:
						cdata = self.data[prod]
						Nevents = len(self.data[self.data.keys()[0]])
				else:
					cdata = zeros(10,dtype="S100")
					cdata[9]="User-Defined Submask: '%s'"%(prod)
					Nevents =10
				if not isinstance(cdata[0],str):
					minval=min(cdata[~isinf(cdata)*~isnan(cdata)])
					maxval=max(cdata[~isinf(cdata)*~isnan(cdata)])
					nanval=~alltrue(~isnan(cdata))
					infval=~alltrue(~isinf(cdata))
					vr = maxval-minval
					rec2 = matplotlib.patches.Rectangle((0.,ypos[pindex]-dh),1.,dh,color=self.dp[prod].get("color"),alpha=0.3)
					ax.add_patch(rec2)
					ax.plot([0.,0.],[ypos[pindex]-dh,ypos[pindex]],"-",color=self.dp[prod].get("color"),lw=2)
					ax.plot([1.,1.],[ypos[pindex]-dh,ypos[pindex]],"-",color=self.dp[prod].get("color"),lw=2)
					ax.text(-0.007,ypos[pindex]-dh*0.6," %4.2f "%minval,horizontalalignment='right',verticalalignment="top",fontsize=6,clip_on=True,rotation="horizontal",weight="bold",zorder=11,color=self.dp[prod].get("color"))
					ax.text(1.005,ypos[pindex]-dh*0.3," %4.2f "%maxval,horizontalalignment='left',verticalalignment="bottom",fontsize=6,clip_on=True,rotation="horizontal",weight="bold",zorder=11,color=self.dp[prod].get("color"))
					if nanval:
						ax.text(-0.007,ypos[pindex]-dh*0.6," NAN ",horizontalalignment='right',verticalalignment="top",fontsize=6,clip_on=True,rotation="horizontal",weight="bold",zorder=11,color=self.dp[prod].get("color"))
					if infval:
						ax.text(1.005,ypos[pindex]-dh*0.3," INF ",horizontalalignment='left',verticalalignment="bottom",fontsize=6,clip_on=True,rotation="horizontal",weight="bold",zorder=11,color=self.dp[prod].get("color"))
					for mindex,sm in enumerate(M.submasks[prod]): 
						minl,maxl,minc,maxc,equ = sm.get_range()
						if equ:  # equal only minv is used
							minv=(minl-minval)/float(vr)
						elif vr>0.:  # range >0 -> minl and maxl need to be set according to operator
							if minl!=None:   # "le","lt"
								minv=(minl-minval)/float(vr)
							else:
								minv=0.
							if maxl!=None:
								maxv=(maxl-minval)/float(vr)
							else:
								maxv=1.
						else:
							minv=0.
							maxv=1.
						if minv<0:
							minv=0.
						if maxv>1.:
							maxv=1.
						if not equ:
							rec = matplotlib.patches.Rectangle((minv,ypos[pindex]-dh),maxv-minv,dh,color=self.dp[prod].get("color"))
							ax.add_patch(rec)
						if minl!=None and minc: 
							ax.plot([minv,minv],[ypos[pindex]-dh,ypos[pindex]],lw=2,c="k")
							ax.plot([minv,minv+0.01],[ypos[pindex],ypos[pindex]],lw=2,c="k")
							ax.plot([minv,minv+0.01],[ypos[pindex]-dh,ypos[pindex]-dh],lw=2,c="k")
						elif equ:
							ax.plot([minv,minv],[ypos[pindex]-dh,ypos[pindex]],lw=2,c="k")
						elif minl!=None:
							ax.plot([minv,minv],[ypos[pindex]-dh,ypos[pindex]],lw=2,c="k")
							ax.plot([minv,minv-0.01],[ypos[pindex],ypos[pindex]],lw=2,c="k")
							ax.plot([minv,minv-0.01],[ypos[pindex]-dh,ypos[pindex]-dh],lw=2,c="k")
						else:
							ax.plot([minv-0.01],[ypos[pindex]-dh/2.],linestyle="",c="k",marker="<",markersize=5)
						if maxl!=None and maxc: 
							ax.plot([maxv,maxv],[ypos[pindex]-dh,ypos[pindex]],lw=2,c="k")
							ax.plot([maxv,maxv-0.01],[ypos[pindex],ypos[pindex]],lw=2,c="k")
							ax.plot([maxv,maxv-0.01],[ypos[pindex]-dh,ypos[pindex]-dh],lw=2,c="k")
						elif equ:
							pass
						elif maxl!=None:
							ax.plot([maxv,maxv],[ypos[pindex]-dh,ypos[pindex]],lw=2,c="k")
							ax.plot([maxv,maxv+0.01],[ypos[pindex],ypos[pindex]],lw=2,c="k")
							ax.plot([maxv,maxv+0.01],[ypos[pindex]-dh,ypos[pindex]-dh],lw=2,c="k")
						else:
							ax.plot([maxv],[ypos[pindex]-dh/2.],linestyle="",c="k",marker=">",markersize=5)
						if equ:
							pass
						else:
							ax.plot([minv,maxv],[ypos[pindex]-dh/2.,ypos[pindex]-dh/2.],lw=1,c="k")
						if minl!=None:
							ax.text(minv-0.007,ypos[pindex]-dh/2.," %s "%minl,horizontalalignment='right',verticalalignment="bottom",fontsize=6,clip_on=True,rotation="horizontal",weight="bold",zorder=11)
						if not equ and maxl!=None:
							ax.text(maxv+0.005,ypos[pindex]-dh/2.," %s "%maxl,horizontalalignment='left',verticalalignment="top",fontsize=6,clip_on=True,rotation="horizontal",weight="bold",zorder=11)

						perc = float(sum(M.calc_submask(prod)*self.DM()))/Nevents
						ax2.plot([0,perc],[ypos[pindex]-dh/2.]*2,color=self.dp[prod].get("color"),lw=2)
						ax2.plot([perc],[ypos[pindex]-dh/2.],color=self.dp[prod].get("color"),ls="",marker="o",markersize=5)

						ax2.text(perc+0.05,ypos[pindex]-dh/2.,"%i"%(perc*100.)+"%",horizontalalignment='left',verticalalignment="center",fontsize=6,clip_on=True,rotation="horizontal",weight="bold",zorder=11)
				else:
					vals=unique(cdata)
					vals.sort()
					for i,val in enumerate(vals):
						ax.text(0+i*0.05,ypos[pindex]-dh/2.," %s "%val,horizontalalignment='left',verticalalignment="center",fontsize=6,clip_on=True,rotation="horizontal",weight="bold",zorder=11)
					for mindex,sm in enumerate(M.submasks[prod]): 
						minl,maxl,minc,maxc,equ = sm.get_range()
						if equ:
							pos=where(vals==minl)[0][0]
							if "MASK2D" not in prod:
								ax.text(0+pos*0.05,ypos[pindex]-dh/2.," %s "%vals[pos],horizontalalignment='right',verticalalignment="center",fontsize=6,clip_on=True,rotation="horizontal",weight="bold",zorder=11,color=self.dp[prod].get("color"))
				if "MASK2D" not in prod:
					ax.text(-0.05,ypos[pindex]-dh/2.,prod,horizontalalignment='right',verticalalignment="center",fontsize=9,backgroundcolor=self.dp[prod].get("color"),rotation="horizontal",weight="bold",color="white",zorder=1,clip_on=False)
				ax2.set_ylabel("%i/%i \n Total: (%3.1f"%(Nmask,Nevents,float(Nmask)/Nevents*100.)+"%)",fontsize=7,weight="bold")
				ax2.yaxis.set_label_position("right")
			ax.yaxis.set_ticks([])
			ax.yaxis.set_ticklabels([])
			ax.xaxis.set_ticklabels([])
			ax.set_xlim(-0.2,1.1)
			ax.set_ylim(-0.0,1.0)
			ax2.yaxis.set_ticks([])
			ax2.yaxis.set_ticklabels([])
			ax2.xaxis.set_ticklabels([])
			ax2.set_xlim(0,1.2)
			ax2.set_ylim(0,1)
	@ArgParser
	def set_mask(self,name,prod,*arg,**kwarg):
		"""
		This Routine sets the mask
		INPUT: name: name of the mask
		prod: dataproduct key
		*arg (list of arguments for the operator)
		**kwarg:
		op: Standard is set to 'between two values'
		possible operators are in general every logic comparators or 
		built-in/user-defined functions
		reset: If set to True all previous masks of the given prod are deleted
		direct: initialize mask directly from binary mask directmask
		directmask: binary mask
		"""
		for mask in name:
			if kwarg.has_key("direct"):
				if kwarg["directmask"]==[]:
					print "In direct mode please supply a binary mask."
				self.mask[mask].set(kwarg["directmask"])
			else:
				if not kwarg.has_key("op"):
					self.mask[mask].add_submask(prod,"be",*arg,**kwarg)
				else:
					self.mask[mask].add_submask(prod,kwarg["op"],*arg,**kwarg)
	def set_mask2D(self,name,prodx,prody,*arg,**kwarg):
		"""
		This Routine sets a 2Dimensional mask, which is achieved by drawing a polygron onto a 2d contour
		INPUT: name: name of the mask
		prodx: 1st dataproduct key
		prody: 2nd dataproduct key
		arg,kwarg: additional keywords for 2dhist plot
		"""
		print "HowTO"
		print "----------"
		print "'a': Add Point"
		print "'r': Remove Last Point"
		print "'c': Cancel"
		print "'Enter': Apply Mask"
		M = mask2D(self,name,prodx,prody)
		M.create_mask2D(*arg,**kwarg)
	def save_subset(self,mask,filename="tmp.dat",prods="all"):
		"""
		This routine save all data of a current mask into a given file. 
		It can be loaded later to work with a reduced data set
		INPUT: mask - the mask that should be saved as a subset
		filename - filepath+filename to which the subset is saved
		prods - either "all" or a list of products
		"""
		subset = {}
		if prods=="all":
			for prod in self.data:
				subset[prod] = self.data[prod][self.mask[mask].get()*self.DM()]
		else:
			for prod in prods:
				subset[prod] = self.data[prod][self.mask[mask].get()*self.DM()]
		cPickle.dump(subset,open(filename,"w"))
	def load_subset(self,filename="tmp.dat",force=False):
		"""
		Loads a subset that is used for further analysis
		!!! This overrides all data loaded by method self.load_data() !!!
		INPUT: mask: 
		"""
		subset=cPickle.load(open(filename,"r"))
		print "!!! Warning !!! - If you Proceed current data set will be overwritten!"
		if force==True or raw_input("Proceed? [Y/N]").lower() in ["yes","y","jo","ja","j"]:
			keys=self.data.keys()
			# Replace old self.data with the loaded data
			for key in keys:
				self.data.pop(key)
			for key in subset:
				self.data[key]=subset[key]
			# Now deal with masks
			for mask in self.mask:
				self.mask[mask].update_mask()
			pkeys=self.dp.keys()
			dkeys=self.data.keys()
			for key in pkeys:
				if not key in dkeys:
					self.dp.pop(key)
			pkeys=self.dp.keys()
			for key in dkeys:
				if not key in pkeys:
					self.dp[key] = plot_properties(key)
					self.dp[key].set("color",self._get_color(len(self.dp)-1))
				#self.mask[mask].calc_mask()
			return True
		else:
			print "Loading subset has been canceled!"
			return False
	def timeseries(self,prody,prodx="time",time=linspace(0,1800,1801),smask=False,avg=False,weights=False,mode="mean",Master=True):
		"""
		This routine creates timeseries of various data products
		INPUT:

		prodx: key of self.data over which the series is plotted (prob. 'time')
		prody: key of self.data that is plotted over time
		time: time bins used for time series - must a ndarray
		smask: list of masks that should be plotted
		weights: weights for the timeseries
		mode: if 'mean': mean of prody inside time bin is plotted over time 
		'sum' : sum of prody inside time bin is plotted over time 
		'freq' : number of occurences of prody inside time bin is plotted over time 
		avg: number of bins (to the left AND right) used for a slindig average
		sliding average is only plotted if avg is passed

		"""
		self.pylabts = pylab.figure()
		pylab.subplots_adjust(hspace=0,wspace=0)
		if smask:
			validmasks=smask
			NPlots = len(validmasks)
		else:
			validmasks = self.mask.keys()
			if Master==False: validmasks.remove("Master")
			NPlots = len(validmasks)
		PCounter = 0
		axtmp = False
		for kindex,key in enumerate(validmasks):
			PCounter+=1
			if axtmp:
				ax = self.pylabts.add_subplot(NPlots,1,PCounter,sharex=axtmp)
			else:
				ax = self.pylabts.add_subplot(NPlots,1,PCounter)
			axtmp=ax
			if PCounter==NPlots:
				ax.set_xlabel(self.dp[prodx].get("name"))
			else:
				ax.xaxis.set_ticklabels([])
			ax.set_ylabel(self.dp[prody].get("name"))
			valx = self.data[prodx][self.mask[key].get()*self.DM()]
			valy = self.data[prody][self.mask[key].get()*self.DM()]
			Counts,binedges = histogram(valx,bins=time)
			ProdY,binedges = histogram(valx,bins=time,weights=valy)
			if mode=="mean":
				plotres = ProdY/Counts
			elif mode=="sum":
				plotres = ProdY
			elif mode=="freq":
				plotres = Counts
			else:
				print "Please enter valid mode!"
				return
			ax.xaxis.grid(True)
			ax.yaxis.grid(True)
			ticks=ax.yaxis.get_major_ticks()
			ticks[0].label.set_visible(False)
			if avg:
				avg_arr = zeros(len(plotres))
				for tindex in range(avg,len(time)-avg):
					dat = plotres[tindex-avg:tindex+avg]
					avg_arr[tindex] = average(dat[isnan(dat)==False])
				ax.plot(time[:-1],plotres,color=self.dp[prody].get("color"),marker="o",markersize=self.dp[prody].get("markersize"),linestyle="")
				ax.plot(time[:-1],avg_arr,c=self.dp[prody].get("color"),lw = self.dp[prody].get("linewidth"),ls = self.dp[prody].get("linestyle"))
			else:
				ax.plot(time[:-1],plotres,c=self.dp[prody].get("color"),lw = self.dp[prody].get("linewidth"),ls = self.dp[prody].get("linestyle"),marker=self.dp[prody].get("marker"),markersize=self.dp[prody].get("markersize"))
			ax.text(self.mp[key].get("label_loc")[0],self.mp[key].get("label_loc")[1],self.mp[key].get("name"),horizontalalignment='left',verticalalignment="bottom",transform=ax.transAxes,backgroundcolor=self.mp[key].get("color"),color="white")
			ax.set_xlim(time[0],time[-1])
		return  plot_mod(self.pylabts,style="timeseries")
	def hist2d(self,prodx,prody,binx=50,biny=50,norm=False,cb=False,weights=False,smask=False,ncols=False,Master=True,xlabel=False,ylabel=False):
		"""
		This routine creates 2D Histograms of two different data products
		TODO: Use proper automatic bins
		INPUT:
		prodx: key of self.data to be histogrammed onto x-axis
		prody: key of self.data to be histogrammed onto y-axis
		binx: xbins for the histogram (number or ndarray)
		biny: ybins for the histogram (number or ndarray)
		norm: can be either 'xmax','xsum','ymax', or 'ysum'
		smask: list of masks that should be plotted
		weights: weights for the histogram
		cb: a string for the colorbar - The colrbar is only plotted if a non empty string is passed
		ncols: number of columns for the 2d histogram
		Master: If True, the Master mask is plotted

		"""
		self.pylab2dh = pylab.figure()
		pylab.subplots_adjust(hspace=0,wspace=0)
		if smask:
			validmasks = smask
		else:
			validmasks = self.mask.keys()
			if Master==False: validmasks.remove("Master")
		NPlots = len(validmasks)
		if ncols:
			Nx = ncols
			if len(validmasks)%int(ncols)==0:
				Ny = int(len(validmasks)/ncols)
			else:
				Ny = int(len(validmasks)/ncols)+1 
		else:
			if NPlots==1:
				Nx,Ny = 1,1
			elif 2>=NPlots>0:
				Nx,Ny = 2,1
			elif 4>=NPlots>2:
				Nx,Ny = 2,2
			elif 6>=NPlots>4:
				Nx,Ny = 3,2
			elif 10>NPlots>6:
				Nx,Ny = 3,3
			elif 12>=NPlots>=10:
				Nx,Ny = 4,3
			elif 16>=NPlots>12:
				Nx,Ny = 4,4
			else:
				print "Too Many Mask or no Mask - Use less than 10 or at least 1 Mask(s) for histogram2d"
				return
		MINX, MAXX = False, False
		MINY, MAXY = False, False
		axtmp = False
		for kindex,key in enumerate(validmasks):
			if axtmp:
				ax = self.pylab2dh.add_subplot(Ny,Nx,kindex+1,sharex=axtmp,sharey=axtmp)
			else:
				ax = self.pylab2dh.add_subplot(Ny,Nx,kindex+1)
			axtmp = ax
			if kindex>=len(validmasks)-Nx: 
				if not xlabel:
					ax.set_xlabel(self.dp[prodx].get("name"))
				else:
					ax.set_xlabel(xlabel)
				ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(prune='both'))
				for tick in ax.xaxis.get_major_ticks():
					tick.label.set_rotation('vertical')
			else:
				for tick in ax.xaxis.get_major_ticks():
					tick.label.set_visible(False)
				ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(prune='both'))
			if (kindex)%Nx==0: 
				if not ylabel:
					ax.set_ylabel(self.dp[prody].get("name"))
				else:
					ax.set_ylabel(ylabel)
				ax.yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(prune='both'))
			else:
				ax.yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(prune='both'))
				for tick in ax.yaxis.get_major_ticks():
					tick.label.set_visible(False)
			valx = self.data[prodx][self.mask[key].get()*self.DM()]
			valy = self.data[prody][self.mask[key].get()*self.DM()]
			if not isinstance(binx,ndarray):
				if alltrue(valx%1==0):
					Nbins = max(self.data[prodx][self.DM()])-min(self.data[prodx][self.DM()])+2
					if Nbins>binx:Nbins=binx
					binx = linspace(min(self.data[prodx][self.DM()]),max(self.data[prodx][self.DM()])+1,Nbins)
			if not isinstance(biny,ndarray):
				if alltrue(valy%1==0):
					Nbins = max(self.data[prody][self.DM()])-min(self.data[prody][self.DM()])+2
					if Nbins>biny:Nbins=biny
					biny = linspace(min(self.data[prody][self.DM()]),max(self.data[prody][self.DM()])+1,Nbins)
			if weights:
				C,X,Y = histogram2d(valx,valy,bins=[binx,biny],weights=self.data[weights][self.mask[key].get()*self.DM()])
			else:
				C,X,Y = histogram2d(valx,valy,bins=[binx,biny])
			if MINX==False or MINX>min(X): MINX=min(X)
			if MAXX==False or MAXX<max(X): MAXX=max(X)
			if MINY==False or MINY>min(Y): MINY=min(Y)
			if MAXY==False or MAXY<max(Y): MAXY=max(Y)
			C=1.*C
			if norm:
				if norm=="ysum":
					for i in range(C.shape[1]):
						if sum(C[:,i])>0:
							C[:,i]/=float(sum(C[:,i]))
				elif norm=="ymax":
					for i in range(C.shape[1]):
						if max(C[:,i])>0:
							C[:,i]/=float(max(C[:,i]))
				elif norm=="xsum":
					for i in range(C.shape[0]):
						if sum(C[i,:])>0:
							C[i,:]/=float(sum(C[i,:]))
				elif norm=="xmax":
					for i in range(C.shape[0]):
						if max(C[i,:])>0:
							C[i,:]/=float(max(C[i,:]))
			colormap = pylab.cm.get_cmap(self.mp[key].get("contourcolor"),1024*16)
			ax.pcolormesh(X,Y,C.T,cmap=colormap,vmin=min(C[C>0]),vmax=max(C))
			colormap.set_under('white')
			ax.text(self.mp[key].get("label_loc")[0],self.mp[key].get("label_loc")[1],self.mp[key].get("name"),horizontalalignment='left',verticalalignment="bottom",transform=ax.transAxes,backgroundcolor=self.mp[key].get("color"),color="white")
			ax.xaxis.grid(True)
			ax.yaxis.grid(True)
		for ax in self.pylab2dh.axes:
			ax.set_xlim(min(X),max(X))
			ax.set_ylim(min(Y),max(Y))
		if cb:
			axcb = pylab.axes([0.9,0.1,0.02,0.8])
			cb1 = matplotlib.mpl.colorbar.ColorbarBase(axcb,cmap=colormap,orientation="vertical",)
			axcb.set_ylabel("%s"%(cb),ha="right")
			cb1.set_ticks([0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0])
			cb1.set_ticklabels(["0.0","0.1","0.2","0.3","","","","0.7","0.8","0.9","1.0"])

		return plot_mod(self.pylab2dh,style="hist2D")
	def quicklook(self,prods=False,cb=False,mask=False,bins=50):
		"""
		This routine creates a quicklook of all available data products
		INPUT:
		prods: List of Products to be plotted
		cb: a string for the colorbar - The colrbar is only plotted if a non empty string is passed
		mask: a string of the mask used for quicklook - if False the Master mask is used
		bins: maximum number of bins for histogram plotting

		"""
		if prods:
			pass
		else:
			prods=self.data.keys()
		N = len(prods)
		self.pylabql = pylab.figure(figsize=(N,N+1))
		pylab.subplots_adjust(hspace=0,wspace=0)
		pC = 0
		print "Processing Data"
		for yN,ykey in enumerate(prods):
			for xN,xkey in enumerate(prods):
				pC+=1
				loading_bar(N*N,pC,">")
				ax = self.pylabql.add_subplot(N+1,N,pC)
				if pC<=N:
					ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10,prune='both'))
					ax.xaxis.set_ticks_position('top')
					ax.xaxis.set_label_position('top')
					for tick in ax.xaxis.get_ticklabels():
						tick.set_rotation('vertical')
						tick.set_size(6)

				else:
					ax.xaxis.set_ticklabels([])
					ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10,prune='both'))
				if N-xN==N: 
					ax.yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10,prune='both'))
					for tick in ax.yaxis.get_ticklabels():
						tick.set_size(6)
				elif xN+1==N and not cb:
					ax.yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10,prune='both'))
					ax.yaxis.set_ticks_position('right')
					ax.yaxis.set_label_position('right')
					for tick in ax.yaxis.get_ticklabels():
						tick.set_size(6)
				else:
					ax.yaxis.set_ticklabels([])
					ax.yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10,prune='both'))
				if mask:
					valx = self.data[xkey][self.mask[mask].get()]
					valy = self.data[ykey][self.mask[mask].get()]
				else:
					valx = self.data[xkey][self.DM()]
					valy = self.data[ykey][self.DM()]
				try:
					binx, biny = bins, bins
					if alltrue(valx%1==0):
						Nbins = max(valx)-min(valx)+2
						if Nbins>bins:Nbins=bins
						binx = linspace(min(valx),max(valx)+1,Nbins)
					if alltrue(valy%1==0):
						Nbins = max(valy)-min(valy)+2
						if Nbins>bins:Nbins=bins
						biny = linspace(min(valy),max(valy)+1,Nbins)
					C,X,Y = histogram2d(valx,valy,bins=(binx,biny))
					C=1.*C
					C = C/sum(C)
					colormap = pylab.cm.get_cmap(self.dp[ykey].get("contourcolor"),1024)
					if yN<xN:
						ax.pcolormesh(X,Y,C.T,cmap=colormap,vmin=min(C[C>0]),vmax=max(C))
						ax.xaxis.grid(True,ls="solid")
						ax.yaxis.grid(True,ls="solid")
					elif yN==xN:
						ax.text(0.5,0.5,self.dp[xkey].get("name"),horizontalalignment='center',verticalalignment="center",transform=ax.transAxes,backgroundcolor=self.dp[xkey].get("color"),color="white")
					else:
						pass
				except:
					pass
				colormap.set_under('white',0)
				ax.set_xlim(min(X),max(X))
				ax.set_ylim(min(Y),max(Y))
				if pC>=N**2-N:
					ax = self.pylabql.add_subplot(N+1,N,pC+N)
					ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(nbins=10,prune='both'))
					for tick in ax.xaxis.get_ticklabels():
						tick.set_rotation('vertical')
						tick.set_size(6)
					ax.yaxis.set_ticklabels([])
					ax.plot(X[:-1],sum(C,axis=1),color=self.dp[xkey].get("color"),lw = self.dp[xkey].get("linewidth"),ls = "steps"+self.dp[xkey].get("linestyle"),marker=self.dp[xkey].get("marker"),markersize=self.dp[xkey].get("markersize"))
		if cb:
			axcb = pylab.axes([0.9,0.1,0.02,0.8])
			cb1 = matplotlib.mpl.colorbar.ColorbarBase(axcb,cmap=colormap,orientation="vertical")
			cb1.set_label("%s"%(cb))
	def hist1d(self,prod,binx=50,norm=False,smask=False,weights=False,Master=True,xlabel=False,ylabel=False,legend=True,legendbox=True):
		"""This routine makes a 1d histogram of the current data
		input: prod: key of self.data to be histogrammed
		binx: bins for the histogram (number or ndarray)
		norm: 'ymax' (normalized to max of hist) or 'ysum' (normalized to sum of hist)
		smask: list of masks that should be plotted
		weights: weights for the histogram (e.g. 'counts')
		Master: If True, the Master mask is plotted
		"""
		self.pylabh = pylab.figure()
		ax = pylab.gca()
		if not xlabel:
			ax.set_xlabel(self.dp[prod].get("name"))
		else:
			ax.set_xlabel(xlabel)
		if not ylabel:
			ax.set_ylabel('N')
		else:
			ax.set_ylabel(ylabel)
		if smask:
			validmasks = smask
		else:
			validmasks = self.mask.keys()
			if Master==False: validmasks.remove("Master")
		valy = self.data[prod][self.DM()]
		if not isinstance(binx,ndarray):
			if alltrue(valy%1==0):
				Nbins = max(self.data[prod][self.DM()])-min(self.data[prod][self.DM()])+2
				if Nbins>binx:Nbins=binx
				binx = linspace(min(self.data[prod][self.DM()]),max(self.data[prod][self.DM()])+1,Nbins)
			else:
				Nbins=binx
				binx = linspace(min(self.data[prod][self.DM()]),max(self.data[prod][self.DM()])+1,Nbins)
		pylab.xlim(binx[0],binx[-1])
		for mask in validmasks:
			valy = self.data[prod][self.mask[mask].get()*self.DM()]
			if weights:
				hist, xvals = histogram(valy,bins=binx,weights=self.data[weights][self.mask[key].get_all()*self.DM()])
			else:
				hist, xvals = histogram(valy,bins=binx)
			hist=1.*hist
			if norm=='ymax':
				hist/=float(max(hist))
			elif norm=="ysum":
				hist/=float(sum(hist))
			elif norm:
				print "Unrecognized norm mode!"
			if smask==False:
				ax.plot(xvals[:-1], hist,label=self.mp[mask].get("name"),color=self.mp[mask].get("color"),lw = self.mp[mask].get("linewidth"),ls = "steps-pre"+self.mp[mask].get("linestyle"),marker=self.mp[mask].get("marker"))
			elif mask in smask:
				ax.plot(xvals[:-1], hist,label=self.mp[mask].get("name"),color=self.mp[mask].get("color"),lw = self.mp[mask].get("linewidth"),ls = "steps-pre"+self.mp[mask].get("linestyle"),marker=self.mp[mask].get("marker"))

		if legend and legendbox:
			pylab.legend()
		elif legend:
			pylab.legend().get_frame().set_visible(False)
		return plot_mod(self.pylabh,style="hist1D")
	def load_data(self):
		"""
		Must be implemented by USER
		"""
		return True

from numpy import append
import scipy.cluster.vq

def generatekmeansmasks(data,k,name="Default",prodlist=[]):
	"""
	For a given data set and expected number of clusters k generatekmeansmasks returns a dictionary of k masks for the products given in prodlist using the k-means algorithm. standard k means assumes that each cluster is a Gaussian
	The dictionary keys are constructed as "name k".
	"""
	traindata=[]
	traindata=numpy.array([data[i] for i in prodlist])
	centeroid, classmask=scipy.cluster.vq.kmeans2(traindata.transpose(),k)
	masks={}
	for i in range(0,k):
		masks[name+' '+str(i+1)]=zeros(data[data.keys()[0]].shape[0],dtype=bool)
	for j in range (1,len(data[data.keys()[0]])):
		masks[name+' '+str(classmask[j]+1)][j] = 1
	return masks

#For debugging and testi
if __name__=="__main__":
	
	from numpy.random import normal

	# EXAMPLE 

	# Here a new class MyData is created that inherits from dbData
	class MyData(dbData):
		# A load_data method is defined that saves data products into the dictionary self.data
		def load_data(self):
			# This small code snippet creates 200000 samples of 2 2D Gaussians at position (3,2) and (14,8)
			self.data["Detector A"] = append(normal(3,3,size=10000),normal(14,2,size=10000))
			self.data["Detector B"] = append(normal(2,4,size=10000),normal(8,3,size=10000))
			# Each events gets a time stamp
			self.data["time"]=linspace(0,100,self.data["Detector A"].shape[0])
	# Create an instance of your class
	d = MyData()
	# Adds 2 masks that separates the 2 2D Gaussians
	d.add_mask("Ion 1")
	d.set_mask("Ion 1","time",0,50)
	d.add_mask("Ion 2")
	d.set_mask("Ion 2","time",50,100)

	# Show the Masks (broken for "direct masks" as from generatekmeansmask because it currently abuses the master mask)
	d.show_mask()

	# Create a 2d Histogram of all masks
	d.hist2d('Detector A',"Detector B",binx=linspace(-20,20,101),biny=linspace(-20,20,101))
	#Create a 1d Histogram of Detector A for all masks (normalized to the sum of the data)
	d.hist1d("Detector A",binx=100,norm="ysum")
	#Plot a time series of the Detector A of masks Ion 1 and Ion 2
	d.timeseries("Detector A",time=linspace(0,100,1001),mode="mean",smask=["Ion 1","Ion 2"])

	# example for kmeans mask:
	maskdict=generatekmeansmasks(d.data,2,"Ion", ["time", "Detector A"])
	d.reset_mask("Ion 1")
	d.set_mask("Ion 1","time", direct=True, directmask=maskdict["Ion 1"])
	d.reset_mask("Ion 2")
	d.set_mask("Ion 2","time", direct=True, directmask=maskdict["Ion 2"])
	d.timeseries("Detector A",time=linspace(0,100,1001),mode="mean",smask=["Ion 1","Ion 2"])
