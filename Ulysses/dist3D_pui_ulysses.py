from swics_collimator_ulysses import collimator
from uswiutils import getvelocity
from ACE.tools.ace_utils import calc_day00
from pylib.etCoord import rotate
from numpy import *
import matplotlib.pyplot as plt
from custom_colours import lighten_color
import sys


class Dist3D(object):
    def __init__(self, d, mass=4., charge=1., aspphistep=1., aspthetastep=1., nrs_perp=1, nrs_para=3, nrs_sec=3,
                 nrs_epq=1, vswbins=arange(300., 800.1, 10.), ion="He1+", offset_sp = 135.):
        """
        d : dbData instance with species predifined by Master mask
        m : Ion mass in amu
        q : Ion charge in e
        """
        self.d = d
        self.aspphistep = aspphistep
        self.aspthetastep = aspthetastep
        self.nrs_para = nrs_para
        self.nrs_perp = nrs_perp
        self.nrs_sec = nrs_sec
        self.nrs_epq = nrs_epq
        self.mass = mass
        self.charge = charge
        self.ion = ion
        self.offset_sp = offset_sp
        self.col_dim = self.nrs_para * self.nrs_perp * self.nrs_sec
        self.sec_det_dim = self.col_dim * self.nrs_epq
        self.aspphi = arange(around(min(self.d.data["aspphi"])),
                             around(max(self.d.data["aspphi"])) + aspphistep + 0.0001, aspphistep)
        self.asptheta = arange(around(min(self.d.data["asptheta"])),
                               around(max(self.d.data["asptheta"])) + aspthetastep + 0.0001, aspthetastep)
        self.vels = getvelocity(self.mass, self.charge, arange(0, 64, 1), frac=1.)
        # nrs_epq -> deltaEpQ is +-5% -> delta v is +-2.5% -> nrs_epq equal spaced velocities in epq direction are
        # generated by vels_fac
        self.vels_fac = linspace(0.975 + 0.025 / self.nrs_epq, 1.025 - 0.025 / self.nrs_epq, self.nrs_epq)
        if not "d00" in self.d.data.keys():
            self.d.add_data("d00", calc_day00(self.d.data["year"], self.d.data["doy"]))
        else:
            self.d.data["d00"] = calc_day00(self.d.data["year"], self.d.data["doy"])
        self.geomfac = 0.0225 * 1e-10
        self.vswbins = vswbins
        self._calc_FoV()
        self._calc_vspace()
        self._add_3Dv()
        self._add_w()
        print('*** calc w space ***')
        self._calc_wspace()
        self._calc_phspeff_wgt()

    def _calc_FoV(self):
        # shape self.FoV: (#aspphi, #asptheta, #det, #sec, xyz, col_dim)
        # (col_dim is nrs_para * nrs_perp * nrs_sec)
        self.FoV = zeros((self.aspphi.shape[0], self.asptheta.shape[0], 3, 8, 3, self.col_dim))
        for iphi, phi in enumerate(self.aspphi):
            for itheta, theta in enumerate(self.asptheta):
                c = collimator(aspphi = phi, asptheta = theta, nrs_perp = self.nrs_perp, nrs_para = self.nrs_para,
                               nrs_sec = self.nrs_sec, offset_sp = self.offset_sp)
                self.FoV[iphi, itheta] = c.FoV

    def _calc_vspace(self):
        """
        Calculates vx,vy,vz for all epqsteps and given aspect angles.
        shape self.vspace: (#aspphi, #asptheta, #epq-steps, #det, #sec, xyz, sec_det_dim)
        (sec_det_dim is col_dim * nrs_epq)
        """
        self.vspace = zeros((self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))
        # not used, just for testing:
        #self.vabsspace = zeros((self.aspphi.shape[0], self.asptheta.shape[0], 60, 3, 8, 1, self.sec_det_dim))
        for i in range(self.nrs_epq):
            for iv, v in enumerate(self.vels):
                self.vspace[:, :, iv, :, :, :, i * self.col_dim:(i + 1) * self.col_dim] = -self.FoV * v * self.vels_fac[
                    i]
        self.vspace[:, :, :, :, :, 1, :] -= 30.
        self.vspace[:, :, :, :, :, 0, :] = -self.vspace[:, :, :, :, :, 0, :]
        self.vspace[:, :, :, :, :, 1, :] = -self.vspace[:, :, :, :, :, 1, :]
        #self.vabsspace[..., 0, :] = sqrt(sum(self.vspace ** 2, axis = 5))

    def _calc_wspace(self, ):
        """
        Calculates vx,vy,vz for all epqsteps and given aspect angles
        """
        self.w3dspace = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))
        self.wspace = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 1, self.sec_det_dim))
        for iv, v in enumerate(self.vswbins[:-1]):
            tmpspace = 1. * self.vspace
            tmpspace[..., 0, :] -= (v + 5.)
            tmpspace /= (v + 5.)
            self.w3dspace[iv, ...] = tmpspace
            self.wspace[iv, ..., 0, :] = sqrt(sum(tmpspace ** 2, axis=5))

    def _add_3Dv(self):
        """
        Adds vx,vy,vz in SC-frame and vxsw,vysw,vzsw in SW-frame based on aspect angles to pha data
        Also adds vxsw2,vysw2,vzsw2 in SW-frame based on aspect angles and rounded vsw to pha data 
        In the current version vsw is taken to be stricly radial, i.e. along v_x / v_R!
        """
        phiind = searchsorted(self.aspphi, around(self.d.get_data('Master',"aspphi")))
        thetaind = searchsorted(self.asptheta, around(self.d.get_data('Master',"asptheta")))
        #epqind = self.d.data["epq"].astype(int)
        epqind = self.d.get_data('Master', 'epq').astype(int)
        detind = self.d.get_data('Master', 'det').astype(int)
        secind = self.d.get_data('Master', 'sec').astype(int)
        if not "vx" in self.d.data.keys():
            self.d.add_data("vx", self.vspace[phiind, thetaind, epqind, detind, secind, 0])
            # a list of 9 entries is added!
        else:
            self.d.data["vx"] = self.vspace[phiind, thetaind, epqind, detind, secind, 0]
        if not "vy" in self.d.data.keys():
            self.d.add_data("vy", self.vspace[phiind, thetaind, epqind, detind, secind, 1])
        else:
            self.d.data["vy"] = self.vspace[phiind, thetaind, epqind, detind, secind, 1]
        if not "vz" in self.d.data.keys():
            self.d.add_data("vz", self.vspace[phiind, thetaind, epqind, detind, secind, 2])
        else:
            self.d.data["vz"] = self.vspace[phiind, thetaind, epqind, detind, secind, 2]
        if not "vxsw" in self.d.data.keys():
            self.d.add_data("vxsw", (self.d.data["vx"].T - self.d.get_data('Master','vsw')).T)
        else:
            self.d.data["vxsw"] = (self.d.data["vx"].T - self.d.get_data('Master','vsw')).T
        if not "vysw" in self.d.data.keys():
            self.d.add_data("vysw", self.d.data["vy"])
        else:
            self.d.data["vysw"] = self.d.data["vy"]
        if not "vzsw" in self.d.data.keys():
            self.d.add_data("vzsw", self.d.data["vz"])
        else:
            self.d.data["vzsw"] = self.d.data["vz"]
        # index 2 in names means vsw speed has been rounded
        if not "vxsw2" in self.d.data.keys():
            self.d.add_data("vxsw2", (self.d.data["vx"].T - around(self.d.data["vsw"], -1)).T)
        else:
            self.d.data["vxsw2"] = (self.d.data["vx"].T - around(self.d.data["vsw"], -1)).T
        if not "vysw2" in self.d.data.keys():
            self.d.add_data("vysw2", self.d.data["vy"])
        else:
            self.d.data["vysw2"] = self.d.data["vy"]
        if not "vzsw2" in self.d.data.keys():
            self.d.add_data("vzsw2", self.d.data["vz"])
        else:
            self.d.data["vzsw2"] = self.d.data["vz"]

    def _add_w(self):
        """
        Adds wxsw,wysw,wzsw and wsw in SW-frame to pha data
        Adds wxsw2,wysw2,wzsw2 and wsw2 in SW-frame to pha data based on rounded vsws!
        """
        if not "wxsw" in self.d.data.keys():
            self.d.add_data("wxsw", (self.d.data["vxsw"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wxsw"] = (self.d.data["vxsw"].T / self.d.data["vsw"]).T
        if not "wysw" in self.d.data.keys():
            self.d.add_data("wysw", (self.d.data["vysw"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wysw"] = (self.d.data["vysw"].T / self.d.data["vsw"]).T
        if not "wzsw" in self.d.data.keys():
            self.d.add_data("wzsw", (self.d.data["vzsw"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wzsw"] = (self.d.data["vzsw"].T / self.d.data["vsw"]).T
        if not "wsw" in self.d.data.keys():
            self.d.add_data("wsw", sqrt(self.d.data["wxsw"] ** 2 + self.d.data["wysw"] ** 2 + self.d.data["wzsw"] ** 2))
        else:
            self.d.data["wsw"] = sqrt(self.d.data["wxsw"] ** 2 + self.d.data["wysw"] ** 2 + self.d.data["wzsw"] ** 2)
        if not "wxsw2" in self.d.data.keys():
            self.d.add_data("wxsw2", (self.d.data["vxsw2"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wxsw2"] = (self.d.data["vxsw2"].T / self.d.data["vsw"]).T
        if not "wysw2" in self.d.data.keys():
            self.d.add_data("wysw2", (self.d.data["vysw2"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wysw2"] = (self.d.data["vysw2"].T / self.d.data["vsw"]).T
        if not "wzsw2" in self.d.data.keys():
            self.d.add_data("wzsw2", (self.d.data["vzsw2"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wzsw2"] = (self.d.data["vzsw2"].T / self.d.data["vsw"]).T
        if not "wsw2" in self.d.data.keys():
            self.d.add_data("wsw2",
                            sqrt(self.d.data["wxsw2"] ** 2 + self.d.data["wysw2"] ** 2 + self.d.data["wzsw2"] ** 2))
        else:
            self.d.data["wsw2"] = sqrt(
                self.d.data["wxsw2"] ** 2 + self.d.data["wysw2"] ** 2 + self.d.data["wzsw2"] ** 2)
        if not "wHe1+2" in self.d.data.keys():
            self.d.add_data("wHe1+2",
                            getvelocity(4., 1., self.d.data["epq"].astype(int)) / around(self.d.data["vsw"],
                                                                                                  -1))
        else:
            self.d.data["wHe1+2"] = getvelocity(4., 1., self.d.data["epq"].astype(int)) / around(
                self.d.data["vsw"], -1)

    def _calc_phspeff_wgt(self):
        """
        Loads ion efficiencies
        ion name, mass and charge must be given at the initialisation of the class object
        """
        fin = open("%s.eff" % (self.ion), "r")
        dat = loadtxt(fin)
        eff = dat[:, 1]
        eff = append(array([0]), eff)
        if not "eff" in self.d.data.keys():
            self.d.add_data("eff", eff[self.d.data["epq"].astype(int)])
        else:
            self.d.data["eff"] = eff[self.d.data["epq"].astype(int)]
        vs = self.vels[self.d.data["epq"].astype(int)]

        if not "wgteffphsp" in self.d.data.keys():
            self.d.add_data("wgteffphsp", (1. / vs ** 4) / self.d.data["eff"])
        else:
            self.d.data["wgteffphsp"] = (1. / vs ** 4) / self.d.data["eff"]

        #### space volume in km**3 (12s for whole spin, but each sec is only scanned for 1.5s)*solid angle coverage(
        # 4*69 whole)*dv from deltaE/Q*efficiencies
        wgts_all = 1. / (vs * 1.5 * self.geomfac) * 1. / (vs ** 2 * (pi ** 2 / 180 ** 2. * 4. * 69)) * 1. / (
                    0.03 * vs) * 1. / self.d.data["eff"]
        #### space volume in km**3 (1.5s for sec)*solid angle coverage(4*33 for sec)*dv from deltaE/Q*efficiencies
        wgts_sec = 1. / (vs * 1.5 * self.geomfac) * 1. / (vs ** 2 * (pi ** 2 / 180 ** 2. * 4. * 23)) * 1. / (
                    0.03 * vs) * 1. / self.d.data["eff"]

        if not "wgts_all" in self.d.data.keys():
            self.d.add_data("wgts_all", wgts_all)
        else:
            self.d.data["wgts_all"] = wgts_all
        if not "wgts_sec" in self.d.data.keys():
            self.d.add_data("wgts_sec", wgts_sec)
        else:
            self.d.data["wgts_sec"] = wgts_sec

    def calc_w3dspecs(self, vswbins=arange(500., 800.1, 10.), wxbins=arange(-2., 2.01, 0.2),
                      wybins=arange(-2., 2.01, 0.2), wzbins=arange(-2., 2.01, 0.2), min_whe=0.9, aspphi=(-20., 20.)):
        """
        Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
        vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
        """
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        #self.d.set_mask("He1+", "wHe1+2", 0., 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)
        # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
        #  to calculate the weights for normalising the final histograms.
        norm_arr = zeros((wxbins.shape[0] - 1, wybins.shape[0] - 1, wzbins.shape[0] - 1))
        uTall,Tallind = unique(self.d.get_data("Master","d00"),return_index=True)
        uasphi = self.d.get_data("Master", "aspphi")[Tallind]
        uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
        uvsw = self.d.get_data("Master", "vsw")[Tallind]
        H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, self.aspphi, self.asptheta))
        ivoffset = int(around(vswbins[0] - self.vswbins[0],
                              -1) / 10)  # funktioniert so nur, wenn beide die gleiche Schrittgroesse haben
        for iv, v in enumerate(vswbins[:-1]):
            for ip, p in enumerate(self.aspphi[:-1]):
                if (p >= aspphi[0]) * (p <= aspphi[1]):
                    for it, t in enumerate(self.asptheta[:-1]):
                        if H[iv, ip, it] > 0:
                            whe = self.vels / (v + 5.)
                            epqs = arange(0, 60, 1)[whe > min_whe]
                            H2, bs = histogramdd((self.w3dspace[iv + ivoffset, ip, it, epqs, ..., 0, :].flatten(),
                                                  self.w3dspace[iv + ivoffset, ip, it, epqs, ..., 1, :].flatten(),
                                                  self.w3dspace[iv + ivoffset, ip, it, epqs, ..., 2, :].flatten()),
                                                 bins=(wxbins, wybins, wzbins))
                            norm_arr += H2 * H[iv, ip, it]
        wgts = self.d.get_data("He1+", "wgts_sec")
        # swgt=self.d.get_data("He1+","swt") ###not available for Ulysses atm!
        wxsw2 = self.d.get_data("He1+", "wxsw2")
        wysw2 = self.d.get_data("He1+", "wysw2")
        wzsw2 = self.d.get_data("He1+", "wzsw2")
        twts = zeros(wxsw2.shape)
        for i in range(wxsw2.shape[1]):
            # twts[:,i]=wgts*swgt ### not available atm
            twts[:, i] = wgts * 1
        H2, bs = histogramdd((wxsw2.flatten(), wysw2.flatten(), wzsw2.flatten()), bins=(wxbins, wybins, wzbins),
                             weights=twts.flatten())
        self.d.remove_submask("He1+", "wHe1+2")
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        return norm_arr, H2


    def plot_wspace(self, ax=None, vsw=2, aspphi=0, asptheta=0, epq=30, sec='all'):
        if ax == None:
            fig = plt.figure(figsize=(6,6))
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('W-Space')
            #ax.set_title('W-Space')
            ax.set_xlim(-2.5, 2.5)
            ax.set_ylim(-2.5, 2.5)
            ax.set_zlim(-2.5, 2.5)
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            w = self.w3dspace[vsw, aspphi, asptheta, epq, :, sec, :, :]
            nrs = w.shape[-2] * w.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(w[..., 0, :], w[..., 1, :], w[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            w = self.w3dspace[vsw, aspphi, asptheta, epq, :, :, :, :]
            for i, s in enumerate(range(w.shape[-3])):
                nrs = w.shape[-2] * w.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(w[..., s, 0, :], w[..., s, 1, :], w[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax

    def plot_vspace(self, ax=None, vsw=20, aspphi=0, asptheta=0, epq=30, sec='all'):
        if ax == None:
            fig = plt.figure(figsize=(6,6))
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('V-Space')
            #ax.set_title('W-Space')
            ax.set_xlim(-600, 600)
            ax.set_ylim(-600, 600)
            ax.set_zlim(-600, 600)
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            v = self.vspace[aspphi, asptheta, epq, :, sec, :, :]
            nrs = v.shape[-2] * v.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(v[..., 0, :], v[..., 1, :], v[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 600], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            v = self.vspace[aspphi, asptheta, epq, :, :, :, :]
            for i, s in enumerate(range(v.shape[-3])):
                nrs = v.shape[-2] * v.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(v[..., s, 0, :], v[..., s, 1, :], v[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 600], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax

    def plot_FoV(self, ax=None, aspphi=0, asptheta=0, sec='all'):
        if ax == None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('FoV')
            #ax.set_title('FoV')
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            f = self.FoV[aspphi, asptheta, :, sec, :, :]
            nrs = f.shape[-2] * f.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(f[..., 0, :], f[..., 1, :], f[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            f = self.FoV[aspphi, asptheta, :, :, :, :]
            for i, s in enumerate(range(f.shape[-3])):
                nrs = f.shape[-2] * f.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(f[..., s, 0, :], f[..., s, 1, :], f[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax


    def plot_wspec(self, dim = 'x', slice = 10, ax = None, min_wHe = 0.9):
        wbins = arange(-2,2.01,0.2)
        norm_arr, H_0 = self.calc_w3dspecs(min_whe = min_wHe)
        norm_arr[norm_arr == 0] = 1
        H = norm_arr/H_0
        if ax == None:
            fig, ax = plt.subplots()
            colormap = plt.cm.get_cmap("viridis")
            if dim == 'x':
                self.Quadmesh = ax.pcolormesh(wbins, wbins, H[slice, :, :].T, cmap=colormap)
                ax.set_xlim(ax.get_xlim()[::-1])
                print(H[slice, :, :])
            elif dim == 'y':
                self.Quadmesh = ax.pcolormesh(wbins, wbins, H[:, slice, :].T, cmap=colormap)
                print(H[:, slice, :])
            elif dim == 'z':
                self.Quadmesh = ax.pcolormesh(wbins, wbins, H[:, :, slice], cmap=colormap)
                ax.set_xlim(ax.get_xlim()[::-1])
                print(H[:, slice, :])
            else:
                print('No valid dimension given')
                sys.exit()

            colorbar = plt.colorbar(self.Quadmesh, ax=ax)
















# _________________ not used atm ________________________________

    #
    # def _calc_pitchangle(self):
    #     # recalc abs(B)
    #     absB = sqrt(self.d.data["Bx"] ** 2 + self.d.data["By"] ** 2 + self.d.data["Bz"] ** 2)
    #     # Calculate unit Vector along B-field
    #     if not "eBx" in self.d.data.keys():
    #         self.d.add_data("eBx", self.d.data["Bx"] / absB)
    #     else:
    #         self.d.data["eBx"] = self.d.data["Bx"] / absB
    #     if not "eBy" in self.d.data.keys():
    #         self.d.add_data("eBy", self.d.data["By"] / absB)
    #     else:
    #         self.d.data["eBy"] = self.d.data["By"] / absB
    #     if not "eBz" in self.d.data.keys():
    #         self.d.add_data("eBz", self.d.data["Bz"] / absB)
    #     else:
    #         self.d.data["eBz"] = self.d.data["Bz"] / absB
    #     # Calculate unit Vector along w vector in solar wind frame
    #     if not "ewx" in self.d.data.keys():
    #         self.d.add_data("ewx", self.d.data["wxsw"] / self.d.data["wsw"])
    #     else:
    #         self.d.data["ewx"] = self.d.data["wxsw"] / self.d.data["wsw"]
    #     if not "ewy" in self.d.data.keys():
    #         self.d.add_data("ewy", self.d.data["wysw"] / self.d.data["wsw"])
    #     else:
    #         self.d.data["ewy"] = self.d.data["wysw"] / self.d.data["wsw"]
    #     if not "ewz" in self.d.data.keys():
    #         self.d.add_data("ewz", self.d.data["wzsw"] / self.d.data["wsw"])
    #     else:
    #         self.d.data["ewz"] = self.d.data["wzsw"] / self.d.data["wsw"]
    #     # Calculate cosine of pitch angle mu by scalar product of eB and and ew.
    #     # Cosmup stands for B-field is still important,i.e. inward field cosmup=1 means the opposite direction
    #     # compared to the solar wind bulk than for outward polarity!
    #     if not "cosmup" in self.d.data.keys():
    #         self.d.add_data("cosmup",
    #                         self.d.data["eBx"] * self.d.data["ewx"] + self.d.data["eBy"] * self.d.data["ewy"] +
    #                         self.d.data["eBz"] * self.d.data["ewz"])
    #     else:
    #         self.d.data["cosmup"] = self.d.data["eBx"] * self.d.data["ewx"] + self.d.data["eBy"] * self.d.data["ewy"]\
    #                                 + \
    #                                 self.d.data["eBz"] * self.d.data["ewz"]
    #     # Cosmu is the cosine on the outward projected B field, i.e. if the polarity is inward cosmu 1 is now
    #     # pointing away from the Sun
    #     if not "cosmu" in self.d.data.keys():
    #         self.d.add_data("cosmu", self.d.data["cosmup"])
    #     else:
    #         self.d.data["cosmu"] = self.d.data["cosmup"]
    #     # inmask very brutally assumes each polarity to be separated in hemispheres (out -45(~parker angle)+-90
    #     # degree -> in 135+-90 degree)
    #     inmask = ~((self.d.data["Bphi"] > -135) * (self.d.data["Bphi"] < 45))
    #     self.d.data["cosmu"][inmask] = -self.d.data["cosmu"][inmask]
    #
    # def _calc_sw_bulk_properties(self):
    #     """
    #     Calculate the solar wind Bulk vector, assuming that the proton core is shifted along B by the alfven speed
    #     from the radial axis
    #     """
    #     # Add alfven speed
    #     if not "valf" in self.d.data.keys():
    #         self.d.add_data("valf", 21.8 * self.d.data["B"] / sqrt(self.d.data["dsw"]))
    #     else:
    #         self.d.data["valf"] = 21.8 * self.d.data["B"] / sqrt(self.d.data["dsw"])
    #     vswy = self.d.data["valf"] * self.d.data["eBy"]
    #     vswz = self.d.data["valf"] * self.d.data["eBz"]
    #     phi = self.d.data["Bphi"]
    #     vswy[(phi > -135) * (phi < 45)] *= -1.
    #     vswz[(phi > -135) * (phi < 45)] *= -1.
    #     vswx = sqrt(self.d.data["vsw"] ** 2 - vswy ** 2 - vswz ** 2)
    #     if not "vswx" in self.d.data.keys():
    #         self.d.add_data("vswx", vswx)
    #     else:
    #         self.d.data["vswx"] = vswx
    #     if not "vswy" in self.d.data.keys():
    #         self.d.add_data("vswy", vswy)
    #     else:
    #         self.d.data["vswy"] = vswy
    #     if not "vswz" in self.d.data.keys():
    #         self.d.add_data("vswz", vswz)
    #     else:
    #         self.d.data["vswz"] = vswz
    #     if not "vxswa" in self.d.data.keys():
    #         self.d.add_data("vxswa", self.d.data["vx"] - vswx)
    #     else:
    #         self.d.data["vxswa"] = self.d.data["vx"] - vswx
    #     if not "vyswa" in self.d.data.keys():
    #         self.d.add_data("vyswa", self.d.data["vy"] - vswy)
    #     else:
    #         self.d.data["vyswa"] = self.d.data["vy"] - vswy
    #     if not "vzswa" in self.d.data.keys():
    #         self.d.add_data("vzswa", self.d.data["vz"] - vswz)
    #     else:
    #         self.d.data["vzswa"] = self.d.data["vz"] - vswz
    #     if not "wxswa" in self.d.data.keys():
    #         self.d.add_data("wxswa", self.d.data["vxswa"] / self.d.data["vsw"])
    #     else:
    #         self.d.data["wxswa"] = self.d.data["vxswa"] / self.d.data["vsw"]
    #     if not "wyswa" in self.d.data.keys():
    #         self.d.add_data("wyswa", self.d.data["vyswa"] / self.d.data["vsw"])
    #     else:
    #         self.d.data["wyswa"] = self.d.data["vyswa"] / self.d.data["vsw"]
    #     if not "wzswa" in self.d.data.keys():
    #         self.d.add_data("wzswa", self.d.data["vzswa"] / self.d.data["vsw"])
    #     else:
    #         self.d.data["wzswa"] = self.d.data["vzswa"] / self.d.data["vsw"]
    #     if not "wswa" in self.d.data.keys():
    #         self.d.add_data("wswa",
    #                         sqrt(self.d.data["wxswa"] ** 2 + self.d.data["wyswa"] ** 2 + self.d.data["wzswa"] ** 2))
    #     else:
    #         self.d.data["wswa"] = sqrt(
    #             self.d.data["wxswa"] ** 2 + self.d.data["wyswa"] ** 2 + self.d.data["wzswa"] ** 2)
    #
    # def calc_wspec_norm(self, vsws=arange(495., 800., 10.), wbins=arange(-1., 5.1, .1), min_whe=0.9):
    #     """
    #     Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
    #     vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
    #     """
    #     self.d.remove_submask("Master", "vsw")
    #     self.d.remove_submask("Master", "aspphi")
    #     self.d.remove_submask("Master", "asptheta")
    #     self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
    #     # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
    #     #  to calculate the weights for normalising the final histograms.
    #     norm_arr = zeros((wbins.shape[0] - 1))
    #     cts_arr = zeros((wbins.shape[0] - 1))
    #     for v in vsws.astype(int):
    #         self.d.set_mask("Master", "vsw", v, v + 10., reset=True)
    #         for phi in self.aspphi[:-1]:
    #             self.d.set_mask("Master", "aspphi", phi - 0.5, phi + 0.5, reset=True)
    #             for theta in self.asptheta[:-1]:
    #                 self.d.set_mask("Master", "asptheta", theta - 0.5, theta + 0.5, reset=True)
    #                 # All times (after Master mask) under which particles could have been measured under given aspect
    #                 #  angle and solar wind speed
    #                 uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
    #                 if uTall.shape[0] == 0.:
    #                     pass
    #                 else:
    #                     phiind = searchsorted(self.aspphi, phi)
    #                     thetaind = searchsorted(self.asptheta, theta)
    #                     whe = self.vels[1] / (v + 5.)
    #                     epqs = arange(0, 60, 1)[whe > min_whe]
    #                     wspace = self.vspace[phiind, thetaind, epqs]
    #                     wspace[:, :, :, 0, :] -= (v + 5.)
    #                     wspace /= (v + 5.)
    #                     wcov = sqrt(sum(wspace ** 2, axis=3))
    #                     wcov[wspace[:, :, :, 0, :] < 0] *= -1.
    #                     H, xbins = histogram(wcov.flatten(), bins=wbins)
    #                     norm_arr += H * uTall.shape[0]
    #                     wgts = self.d.get_data("He1+", "wgts_sec")
    #                     ws = self.d.get_data("He1+", "wsw2")
    #                     wxsw = self.d.get_data("He1+", "wxsw2")
    #                     ws[wxsw < 0] *= -1.
    #                     swgt = self.d.get_data("He1+", "swt")
    #                     H, xbins = histogram(ws, bins=wbins, weights=wgts * swgt)
    #                     cts_arr += H
    #     self.d.remove_submask("He1+", "wHe1+2")
    #     self.d.remove_submask("Master", "vsw")
    #     self.d.remove_submask("Master", "aspphi")
    #     self.d.remove_submask("Master", "asptheta")
    #     return cts_arr, norm_arr
    #
    # def calc_muspec(self, vsws=arange(495., 800., 10.), wbins=arange(0., 5.1, .1), min_whe=0.9, bphi=90., btheta=0.,
    #                 dbphi=10., dbtheta=10., cosmubins=arange(-1., 1.01, .1)):
    #     """
    #     Calculates pitch-angle over w spectra. Data preselected by Master mask.
    #     vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
    #     """
    #     self.d.remove_submask("Master", "vsw")
    #     self.d.remove_submask("Master", "aspphi")
    #     self.d.remove_submask("Master", "asptheta")
    #     self.d.remove_submask("Master", "Bphi")
    #     self.d.remove_submask("Master", "Btheta")
    #     self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
    #     self.d.set_mask("Master", "Bphi", bphi - dbphi, bphi + dbphi, reset=True)
    #     self.d.set_mask("Master", "Btheta", btheta - dbtheta, btheta + dbtheta, reset=True)
    #     # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
    #     #  to calculate the weights for normalising the final histograms.
    #     norm_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
    #     cts_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
    #     B0 = array([1., 0., 0.])
    #     rphiax = array([0., 0., 1.])
    #     rthetaax = rotate(array([0., 1., 0]), rphiax, bphi, deg=True)
    #     B = rotate(B0, rphiax, bphi, deg=True)
    #     B = rotate(B, rthetaax, btheta, deg=True)
    #
    #     for v in vsws.astype(int):
    #         self.d.set_mask("Master", "vsw", v, v + 10., reset=True)
    #         for phi in self.aspphi[:-1]:
    #             self.d.set_mask("Master", "aspphi", phi - 0.5, phi + 0.5, reset=True)
    #             for theta in self.asptheta[:-1]:
    #                 self.d.set_mask("Master", "asptheta", theta - 0.5, theta + 0.5, reset=True)
    #                 # All times (after Master mask) under which particles could have been measured under given aspect
    #                 #  angle and solar wind speed
    #                 uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
    #                 if uTall.shape[0] == 0.:
    #                     pass
    #                 else:
    #                     phiind = searchsorted(self.aspphi, phi)
    #                     thetaind = searchsorted(self.asptheta, theta)
    #                     whe = self.vels[1] / (v + 5.)
    #                     epqs = arange(0, 60, 1)[whe > min_whe]
    #                     wspace = self.vspace[phiind, thetaind, epqs]
    #                     wspace[:, :, :, 0, :] -= (v + 5.)
    #                     wspace /= (v + 5.)
    #                     wcov = sqrt(sum(wspace ** 2, axis=3))
    #                     ewspace = 1. * wspace
    #                     ewspace[:, :, :, 0] = wspace[:, :, :, 0] / wcov[:, :, :]
    #                     ewspace[:, :, :, 1] = wspace[:, :, :, 1] / wcov[:, :, :]
    #                     ewspace[:, :, :, 2] = wspace[:, :, :, 2] / wcov[:, :, :]
    #                     cosmu = ewspace[:, :, :, 0, :] * B[0] + ewspace[:, :, :, 1, :] * B[1] + ewspace[:, :, :, 2,
    #                                                                                             :] * \
    #                             B[2]
    #                     H, xbins, ybins = histogram2d(wcov.flatten(), cosmu.flatten(), bins=(wbins, cosmubins))
    #                     norm_arr += H * uTall.shape[0]
    #                     wgts = self.d.get_data("He1+", "wgts_sec")
    #                     ws = self.d.get_data("He1+", "wsw2")
    #                     wxsw = self.d.get_data("He1+", "wxsw2")
    #                     cmu = self.d.get_data("He1+", "cosmu")
    #                     swgt = self.d.get_data("He1+", "swt")
    #                     H, xbins, ybins = histogram2d(ws, cmu, bins=(wbins, cosmubins), weights=wgts * swgt)
    #                     cts_arr += H
    #     self.d.remove_submask("He1+", "wHe1+2")
    #     self.d.remove_submask("Master", "vsw")
    #     self.d.remove_submask("Master", "aspphi")
    #     self.d.remove_submask("Master", "asptheta")
    #     self.d.remove_submask("Master", "Bphi")
    #     self.d.remove_submask("Master", "Btheta")
    #     return cts_arr, norm_arr, xbins, ybins
    #
    # def calc_wpecs2(self, vswbins=arange(500., 800.1, 10.), wbins=arange(-1., 2.01, 0.1), min_whe=0.9):
    #     """
    #     Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
    #     vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
    #     """
    #     self.d.remove_submask("Master", "vsw")
    #     self.d.remove_submask("Master", "aspphi")
    #     self.d.remove_submask("Master", "asptheta")
    #     self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
    #     # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
    #     #  to calculate the weights for normalising the final histograms.
    #     norm_arr = zeros((wbins.shape[0] - 1))
    #     cts_arr = zeros((wbins.shape[0] - 1))
    #     self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
    #     # self.d.set_mask("Master","wxsw",0.,10000,reset=True)
    #     uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
    #     uasphi = self.d.get_data("Master", "aspphi")[Tallind]
    #     uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
    #     uvsw = self.d.get_data("Master", "vsw")[Tallind]
    #     H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, self.aspphi, self.asptheta))
    #     ivoffset = int(around(vswbins[0] - 300, -1) / 10)
    #     for iv, v in enumerate(vswbins[:-1]):
    #         for ip, p in enumerate(self.aspphi[:-1]):
    #             for it, t in enumerate(self.asptheta[:-1]):
    #                 if H[iv, ip, it] > 0:
    #                     whe = self.vels / (v + 5.)
    #                     epqs = arange(0, 60, 1)[whe > min_whe]
    #                     mask = self.w3dspace[iv + ivoffset, ip, it, epqs, :, :, 0, 0] < 0
    #                     wspace = self.wspace[iv + ivoffset, ip, it, epqs]
    #                     wspace[mask] *= -1.
    #                     # H2,xb = histogram(self.wspace[iv,ip,it,epqs][mask],bins=wbins)
    #                     H2, xb = histogram(wspace, bins=wbins)
    #                     norm_arr += H2 * H[iv, ip, it]
    #     wgts = self.d.get_data("He1+", "wgts_sec")
    #     swgt = self.d.get_data("He1+", "swt")
    #     ws = self.d.get_data("He1+", "wsw2")
    #     wxsw = self.d.get_data("He1+", "wxsw2")
    #     ws[wxsw < 0] *= -1.
    #     H2, xb = histogram(ws, bins=wbins, weights=wgts * swgt)
    #     self.d.remove_submask("He1+", "wHe1+2")
    #     self.d.remove_submask("Master", "vsw")
    #     self.d.remove_submask("Master", "aspphi")
    #     self.d.remove_submask("Master", "asptheta")
    #     return norm_arr, H2
    #
    # def calc_cosmuspecs(self, vswbins=arange(500., 800.1, 10.), cosmubins=arange(-1., 1.01, .2),
    #                     wbins=arange(-0., 2.1, .2), min_whe=0.9, bphibins=arange(-110, -69.9, 10.),
    #                     bthetabins=arange(-20, 20.1, 10.)):
    #     """
    #     Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
    #     vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
    #     """
    #     self.d.remove_submask("Master", "vsw")
    #     self.d.remove_submask("Master", "aspphi")
    #     self.d.remove_submask("Master", "asptheta")
    #     self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
    #     # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
    #     #  to calculate the weights for normalising the final histograms.
    #     norm_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
    #     cts_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
    #     ivoffset = int(around(vswbins[0] - 500, -1) / 10)
    #     self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
    #     for iphi, bphi in enumerate(bphibins[:-1]):
    #         for itheta, btheta in enumerate(bphibins[:-1]):
    #             self.d.set_mask("Master", "Bphi", bphi, bphibins[iphi + 1], reset=True)
    #             self.d.set_mask("Master", "Btheta", btheta, bthetabins[iphi + 1], reset=True)
    #             uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
    #             uasphi = self.d.get_data("Master", "aspphi")[Tallind]
    #             uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
    #             uvsw = self.d.get_data("Master", "vsw")[Tallind]
    #             H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, self.aspphi, self.asptheta))
    #             B0 = array([1., 0., 0.])
    #             rphiax = array([0., 0., 1.])
    #             rthetaax = rotate(array([0., 1., 0]), rphiax, bphi + 5, deg=True)
    #             B = rotate(B0, rphiax, bphi + 5, deg=True)
    #             B = rotate(B, rthetaax, btheta + 5, deg=True)
    #             for iv, v in enumerate(vswbins[:-1]):
    #                 for ip, p in enumerate(self.aspphi[:-1]):
    #                     for it, t in enumerate(self.asptheta[:-1]):
    #                         if H[iv, ip, it] > 0:
    #                             whe = self.vels / (v + 5.)
    #                             epqs = arange(0, 60, 1)[whe > min_whe]
    #                             w3dspace = self.w3dspace[iv + ivoffset, ip, it, epqs]
    #                             wspace = self.wspace[iv + ivoffset, ip, it, epqs]
    #                             w3dspace[..., 0, 0] /= wspace[..., 0, 0]
    #                             w3dspace[..., 1, 0] /= wspace[..., 0, 0]
    #                             w3dspace[..., 2, 0] /= wspace[..., 0, 0]
    #                             cosmuspace = w3dspace[..., 0, 0] * B[0] + w3dspace[..., 1, 0] * B[1] + w3dspace[
    #                                 ..., 2, 0] * B[2]
    #                             H2, xb, yb = histogram2d(wspace.flatten(), cosmuspace.flatten(),
    #                                                      bins=(wbins, cosmubins))
    #                             norm_arr += H2 * H[iv, ip, it]
    #     self.d.set_mask("Master", "Bphi", bphibins[0], bphibins[-1], reset=True)
    #     self.d.set_mask("Master", "Btheta", bthetabins[0], bthetabins[-1], reset=True)
    #     wgts = self.d.get_data("He1+", "wgts_sec")
    #     swgt = self.d.get_data("He1+", "swt")
    #     wsw2 = self.d.get_data("He1+", "wsw2")
    #     cosmu = self.d.get_data("He1+", "cosmu")
    #     H2, xb, yb = histogram2d(wsw2, cosmu, bins=(wbins, cosmubins), weights=(wgts * swgt))
    #     self.d.remove_submask("Master", "Bphi")
    #     self.d.remove_submask("Master", "Btheta")
    #     self.d.remove_submask("He1+", "wHe1+2")
    #     self.d.remove_submask("Master", "vsw")
    #     self.d.remove_submask("Master", "aspphi")
    #     self.d.remove_submask("Master", "asptheta")
    #     return norm_arr, H2
    #
    # def plot_stuff(self, H, wxbins, wybins, wzbins):
    #     """
    #     Just from ipython shell ... will be done next time
    #     """
    #     fig = figure()
    #     for i in range(0, 9):
    #         fig.add_subplot("33%i" % (i + 1))
    #         ax = fig.gca()
    #         sli = H[i + 9]
    #         sli /= amax(sli)
    #         ax.pcolormesh(wbins, wbins, sli.T, cmap="jet", vmax=1.)