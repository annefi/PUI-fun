from swics_collimator_ulysses import collimator
from DataLoader.uswiutils import getvelocity
from ACE.tools.ace_utils import calc_day00
from pylib.etCoord import rotate
from numpy import *
import matplotlib.pyplot as plt
from custom_colours import lighten_color
import matplotlib.colors as colors
import matplotlib.ticker as ticker
import sys
import matplotlib


class Dist3D(object):
    def __init__(self, d, mass=4., charge=1., aspphistep=4., aspthetastep=4., v_sc_step = 1., nrs_perp=2, nrs_para=2,
                 nrs_sec=2, nrs_epq=1, vswbins=arange(300., 800.1, 10.), ion="He1+", offset_sp = 180., sc_vel = True):
        """
        d : dbData instance with species predifined by Master mask
        m : Ion mass in amu
        q : Ion charge in e
        """
        self.d = d
        self.aspphistep = aspphistep
        self.aspthetastep = aspthetastep
        self.nrs_para = nrs_para
        self.nrs_perp = nrs_perp
        self.nrs_sec = nrs_sec
        self.nrs_epq = nrs_epq
        self.mass = mass
        self.charge = charge
        self.ion = ion
        self.sc_vel = sc_vel
        self.offset_sp = offset_sp
        self.col_dim = self.nrs_para * self.nrs_perp * self.nrs_sec
        self.sec_det_dim = self.col_dim * self.nrs_epq
        self.aspphi = arange(around(min(self.d.data["aspphi"])),
                             around(max(self.d.data["aspphi"])) + aspphistep + 0.0001, aspphistep)
        self.asptheta = arange(around(min(self.d.data["asptheta"])),
                               around(max(self.d.data["asptheta"])) + aspthetastep + 0.0001, aspthetastep)

        self.vr = arange(around(min(self.d.data["vr_sc"])),
                               around(max(self.d.data["vr_sc"])) + v_sc_step + 0.0001, v_sc_step)
        self.vt = arange(around(min(self.d.data["vt_sc"])),
                               around(max(self.d.data["vt_sc"])) + v_sc_step + 0.0001, v_sc_step)
        self.vn = arange(around(min(self.d.data["vn_sc"])),
                               around(max(self.d.data["vn_sc"])) + v_sc_step + 0.0001, v_sc_step)



        self.vels = getvelocity(self.mass, self.charge, arange(0, 64, 1), frac=1.)
        # nrs_epq -> deltaEpQ is +-5% -> delta v is +-2.5% -> nrs_epq equal spaced velocities in epq direction are
        # generated by vels_fac
        self.vels_fac = linspace(0.975 + 0.025 / self.nrs_epq, 1.025 - 0.025 / self.nrs_epq, self.nrs_epq)
        if not "d00" in self.d.data.keys():
            self.d.add_data("d00", calc_day00(self.d.data["year"], self.d.data["doy"]))
        else:
            self.d.data["d00"] = calc_day00(self.d.data["year"], self.d.data["doy"])
        self.geomfac = 0.0225 * 1e-10
        self.vswbins = vswbins
        self._calc_FoV()
        self._calc_vspace()
        print('aspphi: ', self.aspphi.shape)
        print('asptheta: ', self.asptheta.shape)
        print('*** calc w space ***')
        self._calc_wspace()
        print('*** add data products ***')
        self._add_3Dv()
        self._add_w()
        self._add_phspeff_wgt()
        self._add_angles()

    def _calc_FoV(self):
        # shape self.FoV: (#aspphi, #asptheta, #det, #sec, xyz, col_dim)
        # (col_dim is nrs_para * nrs_perp * nrs_sec)
        self.FoV = zeros((self.aspphi.shape[0], self.asptheta.shape[0], 3, 8, 3,self.col_dim))
        for iphi, phi in enumerate(self.aspphi):
            for itheta, theta in enumerate(self.asptheta):
                c = collimator(aspphi = phi, asptheta = theta, nrs_perp = self.nrs_perp, nrs_para = self.nrs_para,
                               nrs_sec = self.nrs_sec, offset_sp = self.offset_sp)
                self.FoV[iphi, itheta] = c.FoV

    def _calc_vspace(self):
        """
        Calculates vR,vT,vN for all epqsteps and given aspect angles.
        shape self.vspace: (#aspphi, #asptheta, #vr, #vt, #vn, #epq-steps, #det, #sec, xyz, sec_det_dim)
        (sec_det_dim is col_dim * nrs_epq)
        """
        self.vspace = zeros((self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))
        for i in range(self.nrs_epq):
            for iv, v in enumerate(self.vels):
                self.vspace[:, :, iv, :, :, :, i * self.col_dim:(i + 1) * self.col_dim] = -self.FoV * v * \
                                                                                                   self.vels_fac[i]

        self.vspace[:, :, :, :, :, 0, :] = -self.vspace[:, :, :, :, :, 0, :] # R defined positive from Sun to SC
        self.vspace[:, :, :, :, :, 1, :] = -self.vspace[:, :, :, :, :, 1, :] # positive T in the regular definition

    def _calc_wspace(self, ):
        """
        Calculates vR,vT,vN for all epqsteps and given aspect angles
        """
        self.w3dspace = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))
        self.wspace = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 1, self.sec_det_dim))
        self.w3dspace_sc = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))
        self.wspace_sc = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 1, self.sec_det_dim))
        for iv, v in enumerate(self.vswbins[:-1]):
            tmpspace = 1. * self.vspace
            tmpspace[..., 0, :] -= (v + 5.)
            tmpspace /= (v + 5.)
            self.w3dspace[iv, ...] = tmpspace
            self.wspace[iv, ..., 0, :] = sqrt(sum(tmpspace ** 2, axis=5))
            # SC frame:
            tmpspace_sc = 1. * self.vspace
            tmpspace_sc /= v
            self.w3dspace_sc[iv, ...] = tmpspace_sc
            self.wspace_sc[iv, ..., 0, :] = sqrt(sum(tmpspace_sc ** 2, axis=5))

    def _add_3Dv(self):
        """
        Adds vR,vT,vN in SC-frame and vRsw,vTsw,vNsw in SW-frame based on aspect angles to pha data
        Also adds vRsw2,vTsw2,vNsw2 in SW-frame based on aspect angles and rounded vsw to pha data 
        In the current version vsw is taken to be stricly radial, i.e. along v_x / v_R!
        sc_vel determines, if the velocity of the SC itself should be considered in the v-space.
        """
        phiind = searchsorted(self.aspphi, around(self.d.get_data('Master',"aspphi")))
        thetaind = searchsorted(self.asptheta, around(self.d.get_data('Master',"asptheta")))
        epqind = self.d.get_data('Master', 'epq').astype(int)
        detind = self.d.get_data('Master', 'det').astype(int)
        secind = self.d.get_data('Master', 'sec').astype(int)
        if self.sc_vel == False:
            if not "vR" in self.d.data.keys():
                self.d.add_data("vR", self.vspace[phiind, thetaind, epqind, detind, secind, 0]) # a list of 9 entries
                #  is added!
            else:
                self.d.data["vR"] = self.vspace[phiind, thetaind, epqind, detind, secind, 0]
            if not "vT" in self.d.data.keys():
                self.d.add_data("vT", self.vspace[phiind, thetaind, epqind, detind, secind, 1])
            else:
                self.d.data["vT"] = self.vspace[phiind, thetaind, epqind, detind, secind, 1]
            if not "vN" in self.d.data.keys():
                self.d.add_data("vN", self.vspace[phiind, thetaind, epqind, detind, secind, 2])
            else:
                self.d.data["vN"] = self.vspace[phiind, thetaind, epqind, detind, secind, 2]

            if not "v" in self.d.data.keys():
                self.d.add_data("v",
                                sqrt(self.d.data["vR"] ** 2 + self.d.data["vT"] ** 2 + self.d.data["vN"] ** 2))
            else:
                self.d.data["v"] = sqrt(
                    self.d.data["vR"] ** 2 + self.d.data["vT"] ** 2 + self.d.data["vN"] ** 2)

        elif self.sc_vel == True:
            # considering the velocity of the SC
            if not "vR" in self.d.data.keys():
                self.d.add_data("vR", self.vspace[phiind, thetaind, epqind, detind, secind, 0] + tile(self.d.data[
                    'vr_sc'],(self.sec_det_dim,1)).T)
                # a list of 9 entries is added!
            else:
                self.d.data["vR"] = self.vspace[phiind, thetaind, epqind, detind, secind, 0] + tile(self.d.data[
                    'vr_sc'],(self.sec_det_dim,1)).T
            if not "vT" in self.d.data.keys():
                self.d.add_data("vT", self.vspace[phiind, thetaind, epqind, detind, secind, 1] + tile(self.d.data[
                    'vt_sc'],(self.sec_det_dim,1)).T)
            else:
                self.d.data["vT"] = self.vspace[phiind, thetaind, epqind, detind, secind, 1] + tile(self.d.data[
                    'vt_sc'],(self.sec_det_dim,1)).T
            if not "vN" in self.d.data.keys():
                self.d.add_data("vN", self.vspace[phiind, thetaind, epqind, detind, secind, 2] + tile(self.d.data[
                    'vn_sc'],(self.sec_det_dim,1)).T)
            else:
                self.d.data["vN"] = self.vspace[phiind, thetaind, epqind, detind, secind, 2] + tile(self.d.data[
                    'vn_sc'],(self.sec_det_dim,1)).T

            if not "v" in self.d.data.keys():
                self.d.add_data("v",
                                sqrt(self.d.data["vR"] ** 2 + self.d.data["vT"] ** 2 + self.d.data["vN"] ** 2))
            else:
                self.d.data["v"] = sqrt(
                    self.d.data["vR"] ** 2 + self.d.data["vT"] ** 2 + self.d.data["vN"] ** 2)

        # __________ SW frame _____________________
        if not "vRsw" in self.d.data.keys():
            self.d.add_data("vRsw", (self.d.data["vR"].T - self.d.get_data('Master','vsw')).T)
        else:
            self.d.data["vRsw"] = (self.d.data["vR"].T - self.d.get_data('Master','vsw')).T
        if not "vTsw" in self.d.data.keys():
            self.d.add_data("vTsw", self.d.data["vT"])
        else:
            self.d.data["vTsw"] = self.d.data["vT"]
        if not "vNsw" in self.d.data.keys():
            self.d.add_data("vNsw", self.d.data["vN"])
        else:
            self.d.data["vNsw"] = self.d.data["vN"]

        if not "v_sw" in self.d.data.keys():
            self.d.add_data("v_sw",
                            sqrt(self.d.data["vRsw"] ** 2 + self.d.data["vTsw"] ** 2 + self.d.data["vNsw"] ** 2))
        else:
            self.d.data["v_sw"] = sqrt(
                self.d.data["vRsw"] ** 2 + self.d.data["vTsw"] ** 2 + self.d.data["vNsw"] ** 2)

        # _________index 2 in names means vsw speed has been rounded__________
        if not "vRsw2" in self.d.data.keys():
            self.d.add_data("vRsw2", (self.d.data["vR"].T - around(self.d.data["vsw"], -1)).T)
        else:
            self.d.data["vRsw2"] = (self.d.data["vR"].T - around(self.d.data["vsw"], -1)).T
        if not "vTsw2" in self.d.data.keys():
            self.d.add_data("vTsw2", self.d.data["vT"])
        else:
            self.d.data["vTsw2"] = self.d.data["vT"]
        if not "vNsw2" in self.d.data.keys():
            self.d.add_data("vNsw2", self.d.data["vN"])
        else:
            self.d.data["vNsw2"] = self.d.data["vN"]

    def _add_w(self):
        """
        Adds wRsw,wTsw,wNsw and wsw in SW-frame to pha data
        Adds wRsw2,wTsw2,wNsw2 and wsw2 in SW-frame to pha data based on rounded vsws!
        Adds wR, wT, wN and wsc in SC-frame to pha data
        """

        phiind = searchsorted(self.aspphi, around(self.d.get_data('Master',"aspphi")))
        thetaind = searchsorted(self.asptheta, around(self.d.get_data('Master',"asptheta")))
        vswind = searchsorted(self.vswbins, around(self.d.get_data('Master', "vsw")))
        epqind = self.d.get_data('Master', 'epq').astype(int)
        detind = self.d.get_data('Master', 'det').astype(int)
        secind = self.d.get_data('Master', 'sec').astype(int)

        if not "wR_s" in self.d.data.keys():
            self.d.add_data("wR_s", self.wspace[vswind, phiind, thetaind, epqind, detind, secind, 0])
        else:
            self.d.data["wR_s"] = self.wspace[vswind, phiind, thetaind, epqind, detind, secind, 0]




        if not "wRsw" in self.d.data.keys():
            self.d.add_data("wRsw", (self.d.data["vRsw"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wRsw"] = (self.d.data["vRsw"].T / self.d.data["vsw"]).T
        if not "wTsw" in self.d.data.keys():
            self.d.add_data("wTsw", (self.d.data["vTsw"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wTsw"] = (self.d.data["vTsw"].T / self.d.data["vsw"]).T
        if not "wNsw" in self.d.data.keys():
            self.d.add_data("wNsw", (self.d.data["vNsw"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wNsw"] = (self.d.data["vNsw"].T / self.d.data["vsw"]).T
        if not "wsw" in self.d.data.keys():
            self.d.add_data("wsw", sqrt(self.d.data["wRsw"] ** 2 + self.d.data["wTsw"] ** 2 + self.d.data["wNsw"] ** 2))
        else:
            self.d.data["wsw"] = sqrt(self.d.data["wRsw"] ** 2 + self.d.data["wTsw"] ** 2 + self.d.data["wNsw"] ** 2)
        # _________index 2 in names means vsw speed has been rounded__________
        if not "wRsw2" in self.d.data.keys():
            self.d.add_data("wRsw2", (self.d.data["vRsw2"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wRsw2"] = (self.d.data["vRsw2"].T / self.d.data["vsw"]).T
        if not "wTsw2" in self.d.data.keys():
            self.d.add_data("wTsw2", (self.d.data["vTsw2"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wTsw2"] = (self.d.data["vTsw2"].T / self.d.data["vsw"]).T
        if not "wNsw2" in self.d.data.keys():
            self.d.add_data("wNsw2", (self.d.data["vNsw2"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wNsw2"] = (self.d.data["vNsw2"].T / self.d.data["vsw"]).T
        if not "wsw2" in self.d.data.keys():
            self.d.add_data("wsw2",
                            sqrt(self.d.data["wRsw2"] ** 2 + self.d.data["wTsw2"] ** 2 + self.d.data["wNsw2"] ** 2))
        else:
            self.d.data["wsw2"] = sqrt(
                self.d.data["wRsw2"] ** 2 + self.d.data["wTsw2"] ** 2 + self.d.data["wNsw2"] ** 2)
        if not "wHe1+2" in self.d.data.keys():
            self.d.add_data("wHe1+2",
                            getvelocity(4., 1., self.d.data["epq"].astype(int)) / around(self.d.data["vsw"],
                                                                                                  -1))
        else:
            self.d.data["wHe1+2"] = getvelocity(4., 1., self.d.data["epq"].astype(int)) / around(
                self.d.data["vsw"], -1)

        # ___________________ SC frame __________________________
        # if not "wR" in self.d.data.keys():
        #     self.d.add_data("wR", (self.d.data["vR"].T / self.d.data["vsw"]).T)
        # else:
        #     self.d.data["wR"] = (self.d.data["vR"].T / self.d.data["vsw"]).T
        # if not "wT" in self.d.data.keys():
        #     self.d.add_data("wT", (self.d.data["vT"].T / self.d.data["vsw"]).T)
        # else:
        #     self.d.data["wT"] = (self.d.data["vT"].T / self.d.data["vsw"]).T
        # if not "wN" in self.d.data.keys():
        #     self.d.add_data("wN", (self.d.data["vN"].T / self.d.data["vsw"]).T)
        # else:
        #     self.d.data["wN"] = (self.d.data["vN"].T / self.d.data["vsw"]).T
        # if not "wsc" in self.d.data.keys():
        #     self.d.add_data("wsc", sqrt(self.d.data["wR"] ** 2 + self.d.data["wT"] ** 2 + self.d.data["wN"] ** 2))
        # else:
        #     self.d.data["wsc"] = sqrt(self.d.data["wR"] ** 2 + self.d.data["wT"] ** 2 + self.d.data["wN"] ** 2)

    def _add_angles(self):
        if not "wphi" in self.d.data.keys():
            self.d.add_data("wphi", arctan( - self.d.data['wTsw'] / self.d.data['wRsw']) / pi * 180)
        else:
            self.d.data["wphi"] = arctan( - self.d.data['wTsw'] / self.d.data['wRsw'] / pi * 180)
        if not "wtheta" in self.d.data.keys():
            self.d.add_data("wtheta", arctan(self.d.data['wNsw'] / self.d.data['wRsw']) / pi * 180)
        else:
            self.d.data["wtheta"] = arctan(self.d.data['wNsw'] / self.d.data['wRsw'] / pi * 180)

        if not "wphi_r" in self.d.data.keys():
            self.d.add_data("wphi_r", arctan( - self.d.data['wTsw'] / self.d.data['wRsw']))
        else:
            self.d.data["wphi_r"] = arctan( - self.d.data['wTsw'] / self.d.data['wRsw'])
        if not "wtheta_r" in self.d.data.keys():
            self.d.add_data("wtheta_r", arctan(self.d.data['wNsw'] / self.d.data['wRsw']))
        else:
            self.d.data["wtheta_r"] = arctan(self.d.data['wNsw'] / self.d.data['wRsw'])



    def _add_phspeff_wgt(self):
        """
        Loads ion efficiencies
        ion name, mass and charge must be given at the initialisation of the class object
        """
        fin = open("data_misc/%s.eff" % (self.ion), "r")
        dat = loadtxt(fin)
        eff = dat[:, 1]
        if not "eff" in self.d.data.keys():
            self.d.add_data("eff", eff[self.d.data["epq"].astype(int)])
        else:
            self.d.data["eff"] = eff[self.d.data["epq"].astype(int)]
        vs = self.vels[self.d.data["epq"].astype(int)]

        if not "wgteffphsp" in self.d.data.keys():
            self.d.add_data("wgteffphsp", (1. / vs ** 4) / self.d.data["eff"])
        else:
            self.d.data["wgteffphsp"] = (1. / vs ** 4) / self.d.data["eff"]

        #### space volume in km**3 (12s for whole spin, but each sec is only scanned for 1.5s)*solid angle coverage(
        # 4*69 whole)*dv from deltaE/Q*efficiencies
        wgts_all = 1. / (vs * 1.5 * self.geomfac) * 1. / (vs ** 2 * (pi ** 2 / 180 ** 2. * 4. * 69)) * 1. / (
                    0.03 * vs) * 1. / self.d.data["eff"]
        #### space volume in km**3 (1.5s for sec)*solid angle coverage(4*33 for sec)*dv from deltaE/Q*efficiencies
        wgts_sec = 1. / (vs * 1.5 * self.geomfac) * 1. / (vs ** 2 * (pi ** 2 / 180 ** 2. * 4. * 23)) * 1. / (
                    0.03 * vs) * 1. / self.d.data["eff"]

        if not "wgts_all" in self.d.data.keys():
            self.d.add_data("wgts_all", wgts_all)
        else:
            self.d.data["wgts_all"] = wgts_all
        if not "wgts_sec" in self.d.data.keys():
            self.d.add_data("wgts_sec", wgts_sec)
        else:
            self.d.data["wgts_sec"] = wgts_sec

    def get_norm(self, vswbins = arange(500., 800.1, 10.), aspphi = (-30., 30.), min_whe = 0.9,
                        wbins = arange(-2., 2.01, 0.2), dim = 3, frame = 'sw'):
        '''
        Calculates norm_array for weighting the histogram bins relative to how often a bins has been seen:
        For each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
        to calculate the weights for normalising the final histograms

        :param vswbins: vsw bins over which the normalisation is performed
        :param aspphi: aspphi bins over which the normalisation is performed
        :param min_whe: Lower border for w_He
        :param wbins: bins for the final histogram and also range of the resulting norm_array. Attention: Atm
        wbins are used for all three dimension even with 3D
        :param dim: can be 1 (for spectrum of absolute values) or 3 (for 3D representation)
        :return: norm_array that is either an 1D or 3D array with the range of wbins in each dimension
        '''
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # find unique time stamps and the resp. AAs and vsw:
        uTall,Tallind = unique(self.d.get_data("Master","d00"),return_index=True)
        uasphi = self.d.get_data("Master", "aspphi")[Tallind]
        uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
        uvsw = self.d.get_data("Master", "vsw")[Tallind]
        # H indicates how often a particular aspphi-asptheta-usw combination occurs (= how often did ULYSSES see this
        # angle with this vsw?)
        H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, self.aspphi, self.asptheta))
        # synchronise vsw indices: (funktioniert so nur, wenn beide die gleiche Schrittgroesse haben)
        ivoffset = int(around(vswbins[0] - self.vswbins[0], -1) / 10)

        # norm_arr indicates how often a wR-wT-wN combination "is hit" with the given AA-vsw combinations and their
        # resp. occurrences
        if dim == 1 or dim == 'x':
            norm_arr = zeros((wbins.shape[0] - 1))
        if dim == 3:
            norm_arr = zeros((wbins.shape[0] - 1,wbins.shape[0] - 1,wbins.shape[0] - 1))
        for iv, v in enumerate(vswbins[:-1]):
            for ip, p in enumerate(self.aspphi[:-1]):
                if (p >= aspphi[0]) * (p <= aspphi[1]):
                    for it, t in enumerate(self.asptheta[:-1]):
                        if H[iv, ip, it] > 0:
                            whe = self.vels / (v + 5.)
                            epqs = arange(0, 64, 1)[whe > min_whe]
                            if dim == 1:
                                if frame == "sw":
                                    H2, bs = histogram(self.wspace[iv + ivoffset, ip, it, epqs, ...].flatten(), bins = wbins)
                                # elif frame == "sc":
                                #     H2, bs = histogram(self.wspace_sc[iv + ivoffset, ip, it, epqs, ...].flatten(),
                                #                        bins = wbins)
                            if dim == 3:
                                if frame == 'sw':
                                    H2, bs = histogramdd((self.w3dspace[iv + ivoffset, ip, it, epqs, ..., 0, :].flatten(),
                                                          self.w3dspace[iv + ivoffset, ip, it, epqs, ..., 1, :].flatten(),
                                                          self.w3dspace[iv + ivoffset, ip, it, epqs, ..., 2, :].flatten()),
                                                         bins=(wbins, wbins, wbins))
                                # elif frame == 'sc':
                                #     H2, bs = histogramdd(
                                #         (self.w3dspace_sc[iv + ivoffset, ip, it, epqs, ..., 0, :].flatten(),
                                #          self.w3dspace_sc[iv + ivoffset, ip, it, epqs, ..., 1, :].flatten(),
                                #          self.w3dspace_sc[iv + ivoffset, ip, it, epqs, ..., 2, :].flatten()),
                                #         bins=(wbins, wbins, wbins))
                            norm_arr += H2 * H[iv, ip, it]
        return norm_arr

    def get_norm_shells(self, vswbins = arange(500., 800.1, 10.), aspphi = (-30., 30.), min_whe = 0.0,
             phibins = arange(-180, 180, 10.), thetabins = arange(-180, 180, 10.), wshellbins = arange(0, 2, 0.2)):
        '''
        Calculates norm_array for weighting the histogram bins relative to how often a bins has been seen:
        For each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
        to calculate the weights for normalising the final histograms

        :param vswbins: vsw bins over which the normalisation is performed
        :param aspphi: aspphi bins over which the normalisation is performed
        :param min_whe: Lower border for w_He
        :param wbins: bins for the final histogram and also range of the resulting norm_array. Attention: Atm
        wbins are used for all three dimension even with 3D
        :param dim: can be 1 (for spectrum of absolute values) or 3 (for 3D representation)
        :return: norm_array that is either an 1D or 3D array with the range of wbins in each dimension
        '''
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # find unique time stamps and the resp. AAs and vsw:
        uTall,Tallind = unique(self.d.get_data("Master","d00"),return_index=True)
        uasphi = self.d.get_data("Master", "aspphi")[Tallind]
        uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
        uvsw = self.d.get_data("Master", "vsw")[Tallind]
        # H indicates how often a particular aspphi-asptheta-usw combination occurs (= how often did ULYSSES see this
        # angle with this vsw?)
        H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, self.aspphi, self.asptheta))
        # synchronise vsw indices: (funktioniert so nur, wenn beide die gleiche Schrittgroesse haben)
        ivoffset = int(around(vswbins[0] - self.vswbins[0], -1) / 10)

        # norm_arr indicates how often a wR-wT-wN combination "is hit" with the given AA-vsw combinations and their
        # resp. occurrences
        norm_arr = zeros((phibins.shape[0] - 1,thetabins.shape[0] - 1,wshellbins.shape[0] - 1))
        for iv, v in enumerate(vswbins[:-1]):
            for ip, p in enumerate(self.aspphi[:-1]):
                if (p >= aspphi[0]) * (p <= aspphi[1]):
                    for it, t in enumerate(self.asptheta[:-1]):
                        if H[iv, ip, it] > 0:
                            whe = self.vels / (v + 5.)
                            epqs = arange(0, 64, 1)[whe > min_whe]
                            H2, bs = histogramdd((self.w3dspace[iv + ivoffset, ip, it, epqs, ..., 0, :].flatten(),
                                                      self.w3dspace[iv + ivoffset, ip, it, epqs, ..., 1, :].flatten(),
                                                      self.w3dspace[iv + ivoffset, ip, it, epqs, ..., 2, :].flatten()),
                                                     bins=(phibins, thetabins, wshellbins))
                            norm_arr += H2 * H[iv, ip, it]
        return norm_arr


    def calc_w3dspecs(self, vswbins=arange(500., 800.1, 10.), wRbins=arange(-2., 2.01, 0.2),
                      wTbins=arange(-2., 2.01, 0.2), wNbins=arange(-2., 2.01, 0.2), min_whe=0.9, aspphi=(-30., 30.)):
        """
        Calculates w spectra in slices
        vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
        """
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
        # to calculate the weights for normalising the final histograms:
        norm_arr_sw = self.get_norm(vswbins=vswbins, aspphi=aspphi, min_whe = min_whe, wbins= wRbins, dim = 3,
                                    frame = 'sw')
        # norm_arr_sc = self.get_norm(vswbins=vswbins, aspphi=aspphi, min_whe = min_whe, wbins= wRbins, dim = 3,
        #                             frame = 'sc')

        # consider the PHA words *only now*:
        wgts = self.d.get_data("He1+", "wgts_sec") # 1 / (phase space volume * eff)
        swgt = self.d.get_data("He1+","brw") ### real sector weight not available for Ulysses

        wRsw2 = self.d.get_data("He1+", "wRsw2")
        wTsw2 = self.d.get_data("He1+", "wTsw2")
        wNsw2 = self.d.get_data("He1+", "wNsw2")

        # wRsc = self.d.get_data("He1+", "wR")
        # wTsc = self.d.get_data("He1+", "wT")
        # wNsc = self.d.get_data("He1+", "wN")

        twts = zeros(wRsw2.shape)
        for i in range(wRsw2.shape[1]):
            twts[:,i] = wgts*swgt
        H2_sw, bs = histogramdd((wRsw2.flatten(), wTsw2.flatten(), wNsw2.flatten()), bins=(wRbins, wTbins, wNbins),
                             weights=twts.flatten())
        # H2_sc, bs = histogramdd((wRsc.flatten(), wTsc.flatten(), wNsc.flatten()), bins=(wRbins, wTbins, wNbins),
        #                      weights=twts.flatten())
        self.d.remove_submask("He1+", "wHe1+2")
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        #return norm_arr_sw, H2_sw, norm_arr_sc, H2_sc
        return norm_arr_sw, H2_sw


    def plot_wspec(self, dim = 'x', slice = 10, ax = None, min_wHe = 0.9, mode = 'ps'):
        '''
        :param dim:
        :param slice:
        :param ax:
        :param min_wHe:
        :param mode: Decides whether counts, phase space or norm array are plotted
        :return:
        '''
        wbins = arange(-2,2.01,0.2)
        norm_arr, H_0 = self.calc_w3dspecs(min_whe = min_wHe)
        if mode == 'norm':
            H = norm_arr
        elif mode == 'counts':
            H = H_0
        elif mode == 'ps':
            norm_arr[norm_arr == 0] = 1
            H = H_0/norm_arr
        if ax == None:
            fig, ax = plt.subplots(figsize=(10,8))
            colormap = plt.cm.get_cmap("viridis")
            if dim == 'x':
                self.Quadmesh = ax.pcolormesh(wbins, wbins, H[slice, :, :].T, cmap=colormap)
                ax.set_xlim(ax.get_xlim()[::-1])
                plane = 'Y-Z'
            elif dim == 'y':
                self.Quadmesh = ax.pcolormesh(wbins, wbins, H[:, slice, :].T, cmap=colormap)
                plane = 'X-Z'
            elif dim == 'z':
                self.Quadmesh = ax.pcolormesh(wbins, wbins, H[:, :, slice], cmap=colormap)
                plane = 'X-Y'
                ax.set_xlim(ax.get_xlim()[::-1])
            else:
                print('No valid dimension given')
                sys.exit()
            # Text boxes:
            ax.text(0.1, 1.05, '%s-plane' % plane, bbox={"facecolor": "grey", "alpha": 0.4, "pad": 10},
                       transform=ax.transAxes)
            ax.text(0.8, 1.05, r'$w_x = [%2.1f, %2.1f]$' % (wbins[slice], wbins[slice+1]), bbox={"facecolor": "grey",
                                  "alpha": 0.4, "pad": 10}, transform=ax.transAxes)
            colorbar = plt.colorbar(self.Quadmesh, ax=ax)

    def hist_sec_det(self, polar = True, binx = arange(0,4,1), biny = arange(0,9,1)):
        colormap = plt.cm.get_cmap("viridis")
        valsec = self.d.data['sec']
        valdet = self.d.data['det']
        C, bins_det, bins_sec = histogram2d(valdet, valsec, bins=[binx, biny])
        self.C = C
        self.bins_det = bins_det
        self.bins_sec = bins_sec
        if polar == True:
            fig = plt.figure(figsize=(3,3))
            ax = plt.subplot(111, projection='polar')
            ax.set_ylim(0,2.8)
            ax.set_yticks([])
            ax.set_theta_zero_location('N')
            ax.set_xticks([x + (2 * pi / 16.) for x in linspace(0, 2 * pi, 8, endpoint=False)])
            ax.set_xticklabels([str(i) for i in arange(0, 8, 1)])
            radbins_sec = linspace(0,2*pi,9)
            fullbins_det = array([3.2,2,1,0])
            Mesh = ax.pcolormesh(radbins_sec, fullbins_det, C, cmap = colormap, norm = colors.LogNorm())
        else:
            fig, ax = plt.subplots()
            ax.set_xlabel('Detector')
            ax.set_xticks(arange(0,4,1))
            ax.set_ylabel('Sector')
            ax.set_xticks(arange(0, 9, 1))
            ax.xaxis.set_major_formatter(ticker.NullFormatter())
            ax.xaxis.set_minor_locator(ticker.FixedLocator([0.5, 1.5, 2.5]))
            ax.xaxis.set_minor_formatter(ticker.FixedFormatter(['1','2','3']))

            ax.yaxis.set_major_formatter(ticker.NullFormatter())
            ax.yaxis.set_minor_locator(ticker.FixedLocator([0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]))
            ax.yaxis.set_minor_formatter(ticker.FixedFormatter(['0', '1', '2', '3', '4', '5', '6', '7']))

            for tick in ax.xaxis.get_minor_ticks():
                tick.tick1line.set_markersize(0)
                #tick.label1.set_horizontalalignment('center')
            for tick in ax.yaxis.get_minor_ticks():
                tick.tick1line.set_markersize(0)
                #tick.label1.set_horizontalalignment('center')
            Mesh = ax.pcolormesh(bins_det, bins_sec, C.T, cmap=colormap, norm = colors.LogNorm())
        colormap.set_under('white')
        cb = plt.colorbar(Mesh, ax=ax, extend='max')

    def calc_vabs(self, vsw_val = 400, doy_val = False):
        '''
        Calculates the absolute |v| from vR, vT and vN to compare it with the solar wind velocity in a small window
        of time
        (Built for comparing the He2+ velocity with SWOOPS' measured vsw)
        :return:
        '''
        if doy_val == False:
            try:
                self.d.remove_submask('mmask', 'doy')
            except:
                pass
            self.d.set_mask('mmask','vsw',vsw_val-20, vsw_val+20, reset = True)
        else:
            try:
                self.d.remove_submask('mmask', 'vsw')
            except:
                pass
            self.d.set_mask('mmask', 'doy', doy_val - 0.3, doy_val + 0.3, reset=True)
        vsw = self.d.get_data('mmask', 'vsw').flatten()
        vR = self.d.get_data('mmask','vR').flatten()
        vT = self.d.get_data('mmask','vT').flatten()
        vN = self.d.get_data('mmask','vN').flatten()
        v = sqrt(vR**2 + vT**2 + vN**2)
        fig = plt.figure()
        ax = plt.subplot(111)
        v_bins = arange(200,1000,10)
        hist_bulk, bins = histogram(v, bins = v_bins)
        hist_bulk = append(hist_bulk,0)

        hist_vsw, bins = histogram(tile(vsw,self.sec_det_dim), bins = v_bins)
        hist_vsw = append(hist_vsw, 0)

        ax.plot(bins[:], hist_bulk, ls='steps-post-', color='r', label='calculated bulk velocity')
        ax.plot(bins[:], hist_vsw, ls='steps-post-', color='b', label='SWOOPS solar wind velocity')
        ax.legend()
        return v
    def wspec_1d(self, vswbins=arange(500., 800.1, 10.), wbins=arange(-2., 4.01, 0.2), min_whe=0.0, aspphi=(-30.,30.)):
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
        # to calculate the weights for normalising the final histograms:

        norm_arr_sw = self.get_norm(vswbins=vswbins, aspphi=aspphi, min_whe = min_whe, wbins=wbins, dim = 1,
                                    frame = 'sw')
        norm_arr_sc = self.get_norm(vswbins=vswbins, aspphi=aspphi, min_whe = min_whe, wbins=wbins, dim = 1,
                                    frame = 'sc')

        # consider the PHA words *only now*:
        wgts = self.d.get_data("He1+", "wgts_sec") # 1 / (phase space volume * eff)
        swgt = self.d.get_data("He1+","brw") ### real sector weight not available for Ulysses

        wsw = self.d.get_data('He1+', 'wsw')  # 1D data in solar wind frame
        wsc = self.d.get_data('He1+', 'wsc')  # 1D data in space craft frame

        twts = zeros(wsc.shape)
        for i in range(wsc.shape[1]):
            twts[:,i] = wgts*swgt

        H2_sc, bs = histogram(wsc.flatten(), bins = wbins, weights = twts.flatten())
        H2_sw, bs = histogram(wsw.flatten(), bins = wbins, weights = twts.flatten())

        self.H2_sc = H2_sc
        self.H2_sw = H2_sw

        self.d.remove_submask("He1+", "wHe1+2")
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")

        fig, ax = plt.subplots()

        norm_arr_sw[norm_arr_sw == 0] = 1
        norm_arr_sc[norm_arr_sc == 0] = 1

        H_sc = H2_sc/norm_arr_sc
        H_sw = H2_sw/norm_arr_sw

        H_sc2 = H2_sc/norm_arr_sw

        self.norm_sw = norm_arr_sw
        self.norm_sc = norm_arr_sc
        self.H_sc = H_sc
        self.H_sw = H_sw
        self.H_sc2 = H_sc2

        H_sc = append(H_sc,0)
        H_sw = append(H_sw, 0)
        H_sc2 = append(H_sc2, 0)

        ax.plot(wbins-1, H_sc, ls='steps-post', label= 'SC frame - 1', color='b')
        ax.plot(wbins - 1, H_sc2, ls='steps-post', label='SC frame, false', color='lightblue')
        ax.plot(wbins, H_sw, ls='steps-post', label='SW frame', color='r')
        #ax.set_xlim(-0.5,3)
        ax.legend()

    def calc_skymapspec(self, vswbins = arange(500., 800.1, 10.), phibins = arange(-180, 180, 20), thetabins =
    arange(-180, 180, 20), wshellbins=arange(-1., 3.01, 0.2), min_whe=0.0, aspphi=(-30.,30.)):
        """
        """
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # DOESNT WORK YET
        norm_arr = ones([len(phibins)-1, len(thetabins)-1, len(wshellbins)-1])

        # consider the PHA words *only now*:
        wgts = self.d.get_data("He1+", "wgts_sec") # 1 / (phase space volume * eff)
        swgt = self.d.get_data("He1+","brw") ### real sector weight not available for Ulysses

        wphi = self.d.get_data("He1+", "wphi")
        wtheta = self.d.get_data("He1+", "wtheta")
        w = self.d.get_data("He1+", "wsw")

        twts = zeros(wphi.shape)
        for i in range(wphi.shape[1]):
            twts[:,i] = wgts*swgt
        H, bs = histogramdd((wphi.flatten(), wtheta.flatten(), w.flatten()), bins=(phibins, thetabins, wshellbins),
                             weights=twts.flatten())
        self.d.remove_submask("He1+", "wHe1+2")
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        return norm_arr, H

    def plot_skymapspec(self, shell = 5 , ax = None, min_wHe = 0.9):
        phibins = arange(-180, 180, 20)
        thetabins = arange(-180, 180, 20)
        wshellbins = arange(-1., 3.01, 0.2)

        norm_arr, H0 = self.calc_skymapspec(min_whe = min_wHe)
        norm_arr[norm_arr == 0] = 1
        H = H0 / norm_arr

        colormap = plt.cm.get_cmap("viridis")
        vmin = amin(H[:,:,shell][H[:,:,shell] > 0])
        vmax = amax(H[:,:,shell])
        if vmax < 1.:
            vmax = 10.

        if ax == None:
            fig, ax = plt.subplots(figsize=(10,8))
            colormap = plt.cm.get_cmap("viridis")
            self.Quadmesh = ax.pcolormesh(phibins, thetabins, H[:, :, shell], cmap=colormap, vmin = vmin, vmax = vmax)
            colorbar = plt.colorbar(self.Quadmesh, ax=ax)
            colormap.set_under('white')
            ax.text(0.8, 1.05, 'Shell: %s' % shell, bbox={"facecolor": "grey", "alpha": 0.4, "pad": 10},
                    transform=ax.transAxes)
            ax.text(0.5, 1.05, r'$w = [%2.1f, %2.1f]$' % (wshellbins[shell], wshellbins[shell + 1]),
                    bbox={"facecolor": "grey", "alpha": 0.4, "pad": 10}, transform=ax.transAxes)
        return H





# ____________________ standard plot functions _____________________

    def plot_wspace(self, ax=None, vsw=2, aspphi=0, asptheta=0, epq=30, sec='all'):
        if ax == None:
            fig = plt.figure(figsize=(6,6))
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('W-Space')
            #ax.set_title('W-Space')
            ax.set_xlim(-2.5, 2.5)
            ax.set_ylim(-2.5, 2.5)
            ax.set_zlim(-2.5, 2.5)
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            w = self.w3dspace[vsw, aspphi, asptheta, epq, :, sec, :, :]
            nrs = w.shape[-2] * w.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(w[..., 0, :], w[..., 1, :], w[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            w = self.w3dspace[vsw, aspphi, asptheta, epq, :, :, :, :]
            for i, s in enumerate(range(w.shape[-3])):
                nrs = w.shape[-2] * w.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(w[..., s, 0, :], w[..., s, 1, :], w[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax
    def plot_vspace(self, ax=None, aspphi=-1, asptheta=-1, epq=50, sec='all'):
        if ax == None:
            fig = plt.figure(figsize=(6,6))
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('V-Space')
            #ax.set_title('W-Space')
            ax.set_xlim(-600, 600)
            ax.set_ylim(-600, 600)
            ax.set_zlim(-600, 600)
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            v = self.vspace[aspphi, asptheta, epq, :, sec, :, :]
            nrs = v.shape[-2] * v.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(v[..., 0, :], v[..., 1, :], v[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 600], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            v = self.vspace[aspphi, asptheta, epq, :, :, :, :]
            for i, s in enumerate(range(v.shape[-3])):
                nrs = v.shape[-2] * v.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(v[..., s, 0, :], v[..., s, 1, :], v[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 600], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax
    def plot_FoV(self, ax=None, aspphi=0, asptheta=0, sec='all'):
        if ax == None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('FoV')
            #ax.set_title('FoV')
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            f = self.FoV[aspphi, asptheta, :, sec, :, :]
            nrs = f.shape[-2] * f.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(f[..., 0, :], f[..., 1, :], f[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            f = self.FoV[aspphi, asptheta, :, :, :, :]
            for i, s in enumerate(range(f.shape[-3])):
                nrs = f.shape[-2] * f.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(f[..., s, 0, :], f[..., s, 1, :], f[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax




# # _________________ not used atm ________________________________
#
#
#     def _calc_pitchangle(self):
#         # recalc abs(B)
#         absB = sqrt(self.d.data["Bx"] ** 2 + self.d.data["By"] ** 2 + self.d.data["Bz"] ** 2)
#         # Calculate unit Vector along B-field
#         if not "eBx" in self.d.data.keys():
#             self.d.add_data("eBx", self.d.data["Bx"] / absB)
#         else:
#             self.d.data["eBx"] = self.d.data["Bx"] / absB
#         if not "eBy" in self.d.data.keys():
#             self.d.add_data("eBy", self.d.data["By"] / absB)
#         else:
#             self.d.data["eBy"] = self.d.data["By"] / absB
#         if not "eBz" in self.d.data.keys():
#             self.d.add_data("eBz", self.d.data["Bz"] / absB)
#         else:
#             self.d.data["eBz"] = self.d.data["Bz"] / absB
#         # Calculate unit Vector along w vector in solar wind frame
#         if not "ewR" in self.d.data.keys():
#             self.d.add_data("ewR", self.d.data["wRsw"] / self.d.data["wsw"])
#         else:
#             self.d.data["ewR"] = self.d.data["wRsw"] / self.d.data["wsw"]
#         if not "ewT" in self.d.data.keys():
#             self.d.add_data("ewT", self.d.data["wTsw"] / self.d.data["wsw"])
#         else:
#             self.d.data["ewT"] = self.d.data["wTsw"] / self.d.data["wsw"]
#         if not "ewN" in self.d.data.keys():
#             self.d.add_data("ewN", self.d.data["wNsw"] / self.d.data["wsw"])
#         else:
#             self.d.data["ewN"] = self.d.data["wNsw"] / self.d.data["wsw"]
#         # Calculate cosine of pitch angle mu by scalar product of eB and and ew.
#         # Cosmup stands for B-field is still important,i.e. inward field cosmup=1 means the opposite direction
#         # compared to the solar wind bulk than for outward polarity!
#         if not "cosmup" in self.d.data.keys():
#             self.d.add_data("cosmup",
#                             self.d.data["eBx"] * self.d.data["ewR"] + self.d.data["eBy"] * self.d.data["ewT"] +
#                             self.d.data["eBz"] * self.d.data["ewN"])
#         else:
#             self.d.data["cosmup"] = self.d.data["eBx"] * self.d.data["ewR"] + self.d.data["eBy"] * self.d.data["ewT"]\
#                                     + \
#                                     self.d.data["eBz"] * self.d.data["ewN"]
#         # Cosmu is the cosine on the outward projected B field, i.e. if the polarity is inward cosmu 1 is now
#         # pointing away from the Sun
#         if not "cosmu" in self.d.data.keys():
#             self.d.add_data("cosmu", self.d.data["cosmup"])
#         else:
#             self.d.data["cosmu"] = self.d.data["cosmup"]
#         # inmask very brutally assumes each polarity to be separated in hemispheres (out -45(~parker angle)+-90
#         # degree -> in 135+-90 degree)
#         inmask = ~((self.d.data["Bphi"] > -135) * (self.d.data["Bphi"] < 45))
#         self.d.data["cosmu"][inmask] = -self.d.data["cosmu"][inmask]
#
#     def _calc_sw_bulk_properties(self):
#         """
#         Calculate the solar wind Bulk vector, assuming that the proton core is shifted along B by the alfven speed
#         from the radial axis
#         """
#         # Add alfven speed
#         if not "valf" in self.d.data.keys():
#             self.d.add_data("valf", 21.8 * self.d.data["B"] / sqrt(self.d.data["dsw"]))
#         else:
#             self.d.data["valf"] = 21.8 * self.d.data["B"] / sqrt(self.d.data["dsw"])
#         vswT = self.d.data["valf"] * self.d.data["eBy"]
#         vswN = self.d.data["valf"] * self.d.data["eBz"]
#         phi = self.d.data["Bphi"]
#         vswT[(phi > -135) * (phi < 45)] *= -1.
#         vswN[(phi > -135) * (phi < 45)] *= -1.
#         vswR = sqrt(self.d.data["vsw"] ** 2 - vswT ** 2 - vswN ** 2)
#         if not "vswR" in self.d.data.keys():
#             self.d.add_data("vswR", vswR)
#         else:
#             self.d.data["vswR"] = vswR
#         if not "vswT" in self.d.data.keys():
#             self.d.add_data("vswT", vswT)
#         else:
#             self.d.data["vswT"] = vswT
#         if not "vswN" in self.d.data.keys():
#             self.d.add_data("vswN", vswN)
#         else:
#             self.d.data["vswN"] = vswN
#         if not "vRswa" in self.d.data.keys():
#             self.d.add_data("vRswa", self.d.data["vR"] - vswR)
#         else:
#             self.d.data["vRswa"] = self.d.data["vR"] - vswR
#         if not "vTswa" in self.d.data.keys():
#             self.d.add_data("vTswa", self.d.data["vT"] - vswT)
#         else:
#             self.d.data["vTswa"] = self.d.data["vT"] - vswT
#         if not "vNswa" in self.d.data.keys():
#             self.d.add_data("vNswa", self.d.data["vN"] - vswN)
#         else:
#             self.d.data["vNswa"] = self.d.data["vN"] - vswN
#         if not "wRswa" in self.d.data.keys():
#             self.d.add_data("wRswa", self.d.data["vRswa"] / self.d.data["vsw"])
#         else:
#             self.d.data["wRswa"] = self.d.data["vRswa"] / self.d.data["vsw"]
#         if not "wTswa" in self.d.data.keys():
#             self.d.add_data("wTswa", self.d.data["vTswa"] / self.d.data["vsw"])
#         else:
#             self.d.data["wTswa"] = self.d.data["vTswa"] / self.d.data["vsw"]
#         if not "wNswa" in self.d.data.keys():
#             self.d.add_data("wNswa", self.d.data["vNswa"] / self.d.data["vsw"])
#         else:
#             self.d.data["wNswa"] = self.d.data["vNswa"] / self.d.data["vsw"]
#         if not "wswa" in self.d.data.keys():
#             self.d.add_data("wswa",
#                             sqrt(self.d.data["wRswa"] ** 2 + self.d.data["wTswa"] ** 2 + self.d.data["wNswa"] ** 2))
#         else:
#             self.d.data["wswa"] = sqrt(
#                 self.d.data["wRswa"] ** 2 + self.d.data["wTswa"] ** 2 + self.d.data["wNswa"] ** 2)
#
#     def calc_wspec_norm(self, vsws=arange(495., 800., 10.), wbins=arange(-1., 5.1, .1), min_whe=0.9):
#         """
#         Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
#         vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
#         """
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
#         # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
#         #  to calculate the weights for normalising the final histograms.
#         norm_arr = zeros((wbins.shape[0] - 1))
#         cts_arr = zeros((wbins.shape[0] - 1))
#         for v in vsws.astype(int):
#             self.d.set_mask("Master", "vsw", v, v + 10., reset=True)
#             for phi in self.aspphi[:-1]:
#                 self.d.set_mask("Master", "aspphi", phi - 0.5, phi + 0.5, reset=True)
#                 for theta in self.asptheta[:-1]:
#                     self.d.set_mask("Master", "asptheta", theta - 0.5, theta + 0.5, reset=True)
#                     # All times (after Master mask) under which particles could have been measured under given aspect
#                     #  angle and solar wind speed
#                     uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
#                     if uTall.shape[0] == 0.:
#                         pass
#                     else:
#                         phiind = searchsorted(self.aspphi, phi)
#                         thetaind = searchsorted(self.asptheta, theta)
#                         whe = self.vels[1] / (v + 5.)
#                         epqs = arange(0, 60, 1)[whe > min_whe]
#                         wspace = self.vspace[phiind, thetaind, epqs]
#                         wspace[:, :, :, 0, :] -= (v + 5.)
#                         wspace /= (v + 5.)
#                         wcov = sqrt(sum(wspace ** 2, axis=3))
#                         wcov[wspace[:, :, :, 0, :] < 0] *= -1.
#                         H, xbins = histogram(wcov.flatten(), bins=wbins)
#                         norm_arr += H * uTall.shape[0]
#                         wgts = self.d.get_data("He1+", "wgts_sec")
#                         ws = self.d.get_data("He1+", "wsw2")
#                         wRsw = self.d.get_data("He1+", "wRsw2")
#                         ws[wRsw < 0] *= -1.
#                         swgt = self.d.get_data("He1+", "swt")
#                         H, xbins = histogram(ws, bins=wbins, weights=wgts * swgt)
#                         cts_arr += H
#         self.d.remove_submask("He1+", "wHe1+2")
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         return cts_arr, norm_arr
#
#     def calc_muspec(self, vsws=arange(495., 800., 10.), wbins=arange(0., 5.1, .1), min_whe=0.9, bphi=90., btheta=0.,
#                     dbphi=10., dbtheta=10., cosmubins=arange(-1., 1.01, .1)):
#         """
#         Calculates pitch-angle over w spectra. Data preselected by Master mask.
#         vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
#         """
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.remove_submask("Master", "Bphi")
#         self.d.remove_submask("Master", "Btheta")
#         self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
#         self.d.set_mask("Master", "Bphi", bphi - dbphi, bphi + dbphi, reset=True)
#         self.d.set_mask("Master", "Btheta", btheta - dbtheta, btheta + dbtheta, reset=True)
#         # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
#         #  to calculate the weights for normalising the final histograms.
#         norm_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
#         cts_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
#         B0 = array([1., 0., 0.])
#         rphiax = array([0., 0., 1.])
#         rthetaax = rotate(array([0., 1., 0]), rphiax, bphi, deg=True)
#         B = rotate(B0, rphiax, bphi, deg=True)
#         B = rotate(B, rthetaax, btheta, deg=True)
#
#         for v in vsws.astype(int):
#             self.d.set_mask("Master", "vsw", v, v + 10., reset=True)
#             for phi in self.aspphi[:-1]:
#                 self.d.set_mask("Master", "aspphi", phi - 0.5, phi + 0.5, reset=True)
#                 for theta in self.asptheta[:-1]:
#                     self.d.set_mask("Master", "asptheta", theta - 0.5, theta + 0.5, reset=True)
#                     # All times (after Master mask) under which particles could have been measured under given aspect
#                     #  angle and solar wind speed
#                     uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
#                     if uTall.shape[0] == 0.:
#                         pass
#                     else:
#                         phiind = searchsorted(self.aspphi, phi)
#                         thetaind = searchsorted(self.asptheta, theta)
#                         whe = self.vels[1] / (v + 5.)
#                         epqs = arange(0, 60, 1)[whe > min_whe]
#                         wspace = self.vspace[phiind, thetaind, epqs]
#                         wspace[:, :, :, 0, :] -= (v + 5.)
#                         wspace /= (v + 5.)
#                         wcov = sqrt(sum(wspace ** 2, axis=3))
#                         ewspace = 1. * wspace
#                         ewspace[:, :, :, 0] = wspace[:, :, :, 0] / wcov[:, :, :]
#                         ewspace[:, :, :, 1] = wspace[:, :, :, 1] / wcov[:, :, :]
#                         ewspace[:, :, :, 2] = wspace[:, :, :, 2] / wcov[:, :, :]
#                         cosmu = ewspace[:, :, :, 0, :] * B[0] + ewspace[:, :, :, 1, :] * B[1] + ewspace[:, :, :, 2,
#                                                                                                 :] * \
#                                 B[2]
#                         H, xbins, ybins = histogram2d(wcov.flatten(), cosmu.flatten(), bins=(wbins, cosmubins))
#                         norm_arr += H * uTall.shape[0]
#                         wgts = self.d.get_data("He1+", "wgts_sec")
#                         ws = self.d.get_data("He1+", "wsw2")
#                         wRsw = self.d.get_data("He1+", "wRsw2")
#                         cmu = self.d.get_data("He1+", "cosmu")
#                         swgt = self.d.get_data("He1+", "swt")
#                         H, xbins, ybins = histogram2d(ws, cmu, bins=(wbins, cosmubins), weights=wgts * swgt)
#                         cts_arr += H
#         self.d.remove_submask("He1+", "wHe1+2")
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.remove_submask("Master", "Bphi")
#         self.d.remove_submask("Master", "Btheta")
#         return cts_arr, norm_arr, xbins, ybins
#
#     def calc_wpecs2(self, vswbins=arange(500., 800.1, 10.), wbins=arange(-1., 2.01, 0.1), min_whe=0.9):
#         """
#         Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
#         vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
#         """
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
#         # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
#         #  to calculate the weights for normalising the final histograms.
#         norm_arr = zeros((wbins.shape[0] - 1))
#         cts_arr = zeros((wbins.shape[0] - 1))
#         self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
#         # self.d.set_mask("Master","wRsw",0.,10000,reset=True)
#         uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
#         uasphi = self.d.get_data("Master", "aspphi")[Tallind]
#         uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
#         uvsw = self.d.get_data("Master", "vsw")[Tallind]
#         H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, self.aspphi, self.asptheta))
#         ivoffset = int(around(vswbins[0] - 300, -1) / 10)
#         for iv, v in enumerate(vswbins[:-1]):
#             for ip, p in enumerate(self.aspphi[:-1]):
#                 for it, t in enumerate(self.asptheta[:-1]):
#                     if H[iv, ip, it] > 0:
#                         whe = self.vels / (v + 5.)
#                         epqs = arange(0, 60, 1)[whe > min_whe]
#                         mask = self.w3dspace[iv + ivoffset, ip, it, epqs, :, :, 0, 0] < 0
#                         wspace = self.wspace[iv + ivoffset, ip, it, epqs]
#                         wspace[mask] *= -1.
#                         # H2,xb = histogram(self.wspace[iv,ip,it,epqs][mask],bins=wbins)
#                         H2, xb = histogram(wspace, bins=wbins)
#                         norm_arr += H2 * H[iv, ip, it]
#         wgts = self.d.get_data("He1+", "wgts_sec")
#         swgt = self.d.get_data("He1+", "swt")
#         ws = self.d.get_data("He1+", "wsw2")
#         wRsw = self.d.get_data("He1+", "wRsw2")
#         ws[wRsw < 0] *= -1.
#         H2, xb = histogram(ws, bins=wbins, weights=wgts * swgt)
#         self.d.remove_submask("He1+", "wHe1+2")
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         return norm_arr, H2
#
#     def calc_cosmuspecs(self, vswbins=arange(500., 800.1, 10.), cosmubins=arange(-1., 1.01, .2),
#                         wbins=arange(-0., 2.1, .2), min_whe=0.9, bphibins=arange(-110, -69.9, 10.),
#                         bthetabins=arange(-20, 20.1, 10.)):
#         """
#         Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
#         vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
#         """
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
#         # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
#         #  to calculate the weights for normalising the final histograms.
#         norm_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
#         cts_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
#         ivoffset = int(around(vswbins[0] - 500, -1) / 10)
#         self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
#         for iphi, bphi in enumerate(bphibins[:-1]):
#             for itheta, btheta in enumerate(bphibins[:-1]):
#                 self.d.set_mask("Master", "Bphi", bphi, bphibins[iphi + 1], reset=True)
#                 self.d.set_mask("Master", "Btheta", btheta, bthetabins[iphi + 1], reset=True)
#                 uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
#                 uasphi = self.d.get_data("Master", "aspphi")[Tallind]
#                 uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
#                 uvsw = self.d.get_data("Master", "vsw")[Tallind]
#                 H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, self.aspphi, self.asptheta))
#                 B0 = array([1., 0., 0.])
#                 rphiax = array([0., 0., 1.])
#                 rthetaax = rotate(array([0., 1., 0]), rphiax, bphi + 5, deg=True)
#                 B = rotate(B0, rphiax, bphi + 5, deg=True)
#                 B = rotate(B, rthetaax, btheta + 5, deg=True)
#                 for iv, v in enumerate(vswbins[:-1]):
#                     for ip, p in enumerate(self.aspphi[:-1]):
#                         for it, t in enumerate(self.asptheta[:-1]):
#                             if H[iv, ip, it] > 0:
#                                 whe = self.vels / (v + 5.)
#                                 epqs = arange(0, 60, 1)[whe > min_whe]
#                                 w3dspace = self.w3dspace[iv + ivoffset, ip, it, epqs]
#                                 wspace = self.wspace[iv + ivoffset, ip, it, epqs]
#                                 w3dspace[..., 0, 0] /= wspace[..., 0, 0]
#                                 w3dspace[..., 1, 0] /= wspace[..., 0, 0]
#                                 w3dspace[..., 2, 0] /= wspace[..., 0, 0]
#                                 cosmuspace = w3dspace[..., 0, 0] * B[0] + w3dspace[..., 1, 0] * B[1] + w3dspace[
#                                     ..., 2, 0] * B[2]
#                                 H2, xb, yb = histogram2d(wspace.flatten(), cosmuspace.flatten(),
#                                                          bins=(wbins, cosmubins))
#                                 norm_arr += H2 * H[iv, ip, it]
#         self.d.set_mask("Master", "Bphi", bphibins[0], bphibins[-1], reset=True)
#         self.d.set_mask("Master", "Btheta", bthetabins[0], bthetabins[-1], reset=True)
#         wgts = self.d.get_data("He1+", "wgts_sec")
#         swgt = self.d.get_data("He1+", "swt")
#         wsw2 = self.d.get_data("He1+", "wsw2")
#         cosmu = self.d.get_data("He1+", "cosmu")
#         H2, xb, yb = histogram2d(wsw2, cosmu, bins=(wbins, cosmubins), weights=(wgts * swgt))
#         self.d.remove_submask("Master", "Bphi")
#         self.d.remove_submask("Master", "Btheta")
#         self.d.remove_submask("He1+", "wHe1+2")
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         return norm_arr, H2
#
#     def plot_stuff(self, H, wRbins, wTbins, wNbins):
#         """
#         Just from ipython shell ... will be done next time
#         """
#         fig = figure()
#         for i in range(0, 9):
#             fig.add_subplot("33%i" % (i + 1))
#             ax = fig.gca()
#             sli = H[i + 9]
#             sli /= amax(sli)
#             ax.pcolormesh(wbins, wbins, sli.T, cmap="jet", vmax=1.)