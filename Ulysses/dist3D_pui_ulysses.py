from swics_collimator_ulysses import collimator
from DataLoader.uswiutils import getvelocity
from ACE.tools.ace_utils import calc_day00
from pylib.etCoord import rotate
from numpy import *
import matplotlib.pyplot as plt
from custom_colours import lighten_color
import matplotlib.colors as colors
import matplotlib.ticker as ticker
import sys
import matplotlib
import time
from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,
                               AutoMinorLocator)

matplotlib.rcParams.update({'font.size': 18,
                            'xtick.major.size': 13,
                            'xtick.major.width': 2,
                            'xtick.minor.size': 8,
                            'xtick.minor.width': 1,
                            'ytick.major.size': 13,
                            'ytick.major.width': 2,
                            'ytick.minor.size': 8,
                            'ytick.minor.width': 1})


class Dist3D(object):
    def __init__(self, d, mass=4., charge=1., aspphistep=2., aspthetastep=2., v_sc_step=1., nrs_perp=1, nrs_para=4,
                 nrs_sec=9, nrs_epq=1, ion="He1+", offset_sp=180., sc_vel=True):
        """
        d : dbData instance with species predifined by Master mask
        m : Ion mass in amu
        q : Ion charge in e
        """
        self.d = d
        self.aspphistep = aspphistep
        self.aspthetastep = aspthetastep
        self.nrs_para = nrs_para
        self.nrs_perp = nrs_perp
        self.nrs_sec = nrs_sec
        self.nrs_epq = nrs_epq
        self.mass = mass
        self.charge = charge
        self.ion = ion
        self.sc_vel = sc_vel
        self.offset_sp = offset_sp
        self.col_dim = self.nrs_para * self.nrs_perp * self.nrs_sec
        self.sec_det_dim = self.col_dim * self.nrs_epq
        self.aspphi = arange(around(min(self.d.data["aspphi"])),
                             around(max(self.d.data["aspphi"])) + aspphistep + 0.0001, aspphistep)
        self.asptheta = arange(around(min(self.d.data["asptheta"])),
                               around(max(self.d.data["asptheta"])) + aspthetastep + 0.0001, aspthetastep)

        self.vswbins = arange(around(min(self.d.data["vsw"]), decimals=-1),
                              around(max(self.d.data["vsw"]), decimals=-1) + 10. + 0.0001, 10)

        self.vr = arange(around(min(self.d.data["vr_sc"])),
                         around(max(self.d.data["vr_sc"])) + v_sc_step + 0.0001, v_sc_step)
        self.vt = arange(around(min(self.d.data["vt_sc"])),
                         around(max(self.d.data["vt_sc"])) + v_sc_step + 0.0001, v_sc_step)
        self.vn = arange(around(min(self.d.data["vn_sc"])),
                         around(max(self.d.data["vn_sc"])) + v_sc_step + 0.0001, v_sc_step)

        self.vels = getvelocity(self.mass, self.charge, arange(0, 64, 1), frac=1.)
        # nrs_epq -> deltaEpQ is +-5% -> delta v is +-2.5% -> nrs_epq equal spaced velocities in epq direction are
        # generated by vels_fac
        self.vels_fac = linspace(0.975 + 0.025 / self.nrs_epq, 1.025 - 0.025 / self.nrs_epq, self.nrs_epq)
        if not "d00" in self.d.data.keys():
            self.d.add_data("d00", calc_day00(self.d.data["year"], self.d.data["doy"]))
        else:
            self.d.data["d00"] = calc_day00(self.d.data["year"], self.d.data["doy"])
        self.geomfac = 0.0225 * 1e-10
        # self.vswbins = vswbins
        self._calc_FoV()
        self._calc_vspace()
        print('aspphi: ', self.aspphi.shape)
        print('asptheta: ', self.asptheta.shape)
        print('*** calc w space ***')
        # self._calc_wspace()
        print('*** add data products ***')
        self._add_3Dv()
        self._add_w()
        self._add_phspeff_wgt()
        self._add_angles()

    def _calc_FoV(self):
        # shape self.FoV: (#aspphi, #asptheta, #det, #sec, xyz, col_dim)
        # (col_dim is nrs_para * nrs_perp * nrs_sec)
        self.FoV = zeros((self.aspphi.shape[0], self.asptheta.shape[0], 3, 8, 3, self.col_dim))
        for iphi, phi in enumerate(self.aspphi):
            for itheta, theta in enumerate(self.asptheta):
                c = collimator(aspphi=phi, asptheta=theta, nrs_perp=self.nrs_perp, nrs_para=self.nrs_para,
                               nrs_sec=self.nrs_sec, offset_sp=self.offset_sp)
                self.FoV[iphi, itheta] = c.FoV

    def _calc_vspace(self):
        """
        Calculates vR,vT,vN for all epqsteps and given aspect angles.
        shape self.vspace: (#aspphi, #asptheta, #vr, #vt, #vn, #epq-steps, #det, #sec, xyz, sec_det_dim)
        (sec_det_dim is col_dim * nrs_epq)
        """
        self.vspace = zeros((self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))
        for i in range(self.nrs_epq):
            for iv, v in enumerate(self.vels):
                self.vspace[:, :, iv, :, :, :, i * self.col_dim:(i + 1) * self.col_dim] = -self.FoV * v * \
                                                                                          self.vels_fac[i]

        self.vspace[:, :, :, :, :, 0, :] = -self.vspace[:, :, :, :, :, 0, :]  # R defined positive from Sun to SC
        self.vspace[:, :, :, :, :, 1, :] = -self.vspace[:, :, :, :, :, 1, :]  # positive T in the regular definition

    def _calc_wspace(self):
        """
        Calculates vR,vT,vN for all epqsteps and given aspect angles
        """

        self.w3dspace = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))

        self.wspace = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 1, self.sec_det_dim))

        # self.w3dspace_sc = zeros(
        #     (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))
        # self.wspace_sc = zeros(
        #     (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 1, self.sec_det_dim))
        for iv, v in enumerate(self.vswbins[:-1]):
            tmpspace = 1. * self.vspace
            tmpspace[..., 0, :] -= (v)
            tmpspace /= (v)
            self.w3dspace[iv, ...] = tmpspace
            self.wspace[iv, ..., 0, :] = sqrt(sum(tmpspace ** 2, axis=5))
            print(iv)

            ## SC frame:
            # tmpspace_sc = 1. * self.vspace
            # tmpspace_sc /= v
            # self.w3dspace_sc[iv, ...] = tmpspace_sc
            # self.wspace_sc[iv, ..., 0, :] = sqrt(sum(tmpspace_sc ** 2, axis=5))

    def _add_3Dv(self):
        """
        Adds vR,vT,vN in SC-frame and vRsw,vTsw,vNsw in SW-frame based on aspect angles to pha data
        Also adds vRsw2,vTsw2,vNsw2 in SW-frame based on aspect angles and rounded vsw to pha data 
        In the current version vsw is taken to be stricly radial, i.e. along v_x / v_R!
        sc_vel determines, if the velocity of the SC itself should be considered in the v-space.
        """

        searcharr_phi = arange(self.aspphi[0] + self.aspphistep / 2., self.aspphi[-1], self.aspphistep)
        searcharr_theta = arange(self.asptheta[0] + self.aspthetastep / 2., self.asptheta[-1], self.aspthetastep)

        phiind = searchsorted(searcharr_phi, self.d.get_data('Master', "aspphi"))
        thetaind = searchsorted(searcharr_theta, self.d.get_data('Master', "asptheta"))

        epqind = self.d.get_data('Master', 'epq').astype(int)
        detind = self.d.get_data('Master', 'det').astype(int)
        secind = self.d.get_data('Master', 'sec').astype(int)
        if self.sc_vel == False:
            if not "vR" in self.d.data.keys():
                self.d.add_data("vR", self.vspace[phiind, thetaind, epqind, detind, secind, 0])  # a list of 9 entries
                #  is added!
            else:
                self.d.data["vR"] = self.vspace[phiind, thetaind, epqind, detind, secind, 0]
            if not "vT" in self.d.data.keys():
                self.d.add_data("vT", self.vspace[phiind, thetaind, epqind, detind, secind, 1])
            else:
                self.d.data["vT"] = self.vspace[phiind, thetaind, epqind, detind, secind, 1]
            if not "vN" in self.d.data.keys():
                self.d.add_data("vN", self.vspace[phiind, thetaind, epqind, detind, secind, 2])
            else:
                self.d.data["vN"] = self.vspace[phiind, thetaind, epqind, detind, secind, 2]
            if not "v" in self.d.data.keys():
                self.d.add_data("v",
                                sqrt(self.d.data["vR"] ** 2 + self.d.data["vT"] ** 2 + self.d.data["vN"] ** 2))
            else:
                self.d.data["v"] = sqrt(
                    self.d.data["vR"] ** 2 + self.d.data["vT"] ** 2 + self.d.data["vN"] ** 2)

        elif self.sc_vel == True:
            # considering the velocity of the SC
            if not "vR" in self.d.data.keys():
                self.d.add_data("vR", self.vspace[phiind, thetaind, epqind, detind, secind, 0] + tile(self.d.data[
                    'vr_sc'], ( self.sec_det_dim,1)).T)
                # a list of 9 entries is added!
            else:
                self.d.data["vR"] = self.vspace[phiind, thetaind, epqind, detind, secind, 0] + tile(self.d.data[
                    'vr_sc'], (self.sec_det_dim, 1)).T

            if not "vT" in self.d.data.keys():
                self.d.add_data("vT", self.vspace[phiind, thetaind, epqind, detind, secind, 1] + tile(self.d.data[
                      'vt_sc'], (self.sec_det_dim,1)).T)
            else:
                self.d.data["vT"] = self.vspace[phiind, thetaind, epqind, detind, secind, 1] + tile(self.d.data[
                         'vt_sc'], (self.sec_det_dim,1)).T

            if not "vN" in self.d.data.keys():
                self.d.add_data("vN", self.vspace[phiind, thetaind, epqind, detind, secind, 2] + tile(self.d.data[
                     'vn_sc'], (self.sec_det_dim,1)).T)
            else:
                self.d.data["vN"] = self.vspace[phiind, thetaind, epqind, detind, secind, 2] + tile(self.d.data[
                     'vn_sc'], (self.sec_det_dim,1)).T

            if not "v" in self.d.data.keys():
                self.d.add_data("v",
                                sqrt(self.d.data["vR"] ** 2 + self.d.data["vT"] ** 2 + self.d.data["vN"] ** 2))
            else:
                self.d.data["v"] = sqrt(
                    self.d.data["vR"] ** 2 + self.d.data["vT"] ** 2 + self.d.data["vN"] ** 2)

        # __________ SW frame _____________________
        if not "vRsw" in self.d.data.keys():
            self.d.add_data("vRsw", (self.d.data["vR"].T - self.d.get_data('Master', 'vsw')).T)
        else:
            self.d.data["vRsw"] = (self.d.data["vR"].T - self.d.get_data('Master', 'vsw')).T
        if not "vTsw" in self.d.data.keys():
            self.d.add_data("vTsw", self.d.data["vT"])
        else:
            self.d.data["vTsw"] = self.d.data["vT"]
        if not "vNsw" in self.d.data.keys():
            self.d.add_data("vNsw", self.d.data["vN"])
        else:
            self.d.data["vNsw"] = self.d.data["vN"]
        if not "v_sw" in self.d.data.keys():
            self.d.add_data("v_sw",
                            sqrt(self.d.data["vRsw"] ** 2 + self.d.data["vTsw"] ** 2 + self.d.data["vNsw"] ** 2))
        else:
            self.d.data["v_sw"] = sqrt(
                self.d.data["vRsw"] ** 2 + self.d.data["vTsw"] ** 2 + self.d.data["vNsw"] ** 2)

        # _________index 2 in names means vsw speed has been rounded__________
        if not "vRsw2" in self.d.data.keys():
            self.d.add_data("vRsw2", (self.d.data["vR"].T - around(self.d.data["vsw"], -1)).T)
        else:
            self.d.data["vRsw2"] = (self.d.data["vR"].T - around(self.d.data["vsw"], -1)).T
        if not "vTsw2" in self.d.data.keys():
            self.d.add_data("vTsw2", self.d.data["vT"])
        else:
            self.d.data["vTsw2"] = self.d.data["vT"]
        if not "vNsw2" in self.d.data.keys():
            self.d.add_data("vNsw2", self.d.data["vN"])
        else:
            self.d.data["vNsw2"] = self.d.data["vN"]

    def _add_w(self):
        """
        Adds wRsw,wTsw,wNsw and wsw in SW-frame to pha data
        Adds wRsw2,wTsw2,wNsw2 and wsw2 in SW-frame to pha data based on rounded vsws!
        Adds wR, wT, wN and wsc in SC-frame to pha data
        """
        # # divide the bins each into half and match every count to the central binedge.
        # searcharr_phi = arange(self.aspphi[0] + self.aspphistep / 2., self.aspphi[-1], self.aspphistep)
        # searcharr_theta = arange(self.asptheta[0] + self.aspthetastep / 2., self.asptheta[-1], self.aspthetastep)
        # searcharr_vsw = arange(self.vswbins[0] + 10. / 2, self.vswbins[-1], 10.)
        #
        # vswind = searchsorted(searcharr_vsw, self.d.get_data('Master', "vsw"))
        # phiind = searchsorted(searcharr_phi, self.d.get_data('Master', "aspphi"))
        # # phiind = searchsorted(self.aspphi, around(self.d.get_data('Master',"aspphi")))
        # thetaind = searchsorted(searcharr_theta, self.d.get_data('Master', "asptheta"))
        #
        # epqind = self.d.get_data('Master', 'epq').astype(int)
        # detind = self.d.get_data('Master', 'det').astype(int)
        # secind = self.d.get_data('Master', 'sec').astype(int)
        #
        # # if not "wR_s" in self.d.data.keys():
        # #     self.d.add_data("wR_s", self.w3dspace[vswind, phiind, thetaind, epqind, detind, secind, 0])
        # # else:
        # #     self.d.data["wR_s"] = self.w3dspace[vswind, phiind, thetaind, epqind, detind, secind, 0]
        # # if not "wT_s" in self.d.data.keys():
        # #     self.d.add_data("wT_s", self.w3dspace[vswind, phiind, thetaind, epqind, detind, secind, 1])
        # # else:
        # #     self.d.data["wT_s"] = self.w3dspace[vswind, phiind, thetaind, epqind, detind, secind, 1]
        # # if not "wN_s" in self.d.data.keys():
        # #     self.d.add_data("wN_s", self.w3dspace[vswind, phiind, thetaind, epqind, detind, secind, 2])
        # # else:
        # #     self.d.data["wN_s"] = self.w3dspace[vswind, phiind, thetaind, epqind, detind, secind, 2]

        if not "wRsw" in self.d.data.keys():
            self.d.add_data("wRsw", (self.d.data["vRsw"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wRsw"] = (self.d.data["vRsw"].T / self.d.data["vsw"]).T
        if not "wTsw" in self.d.data.keys():
            self.d.add_data("wTsw", (self.d.data["vTsw"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wTsw"] = (self.d.data["vTsw"].T / self.d.data["vsw"]).T
        if not "wNsw" in self.d.data.keys():
            self.d.add_data("wNsw", (self.d.data["vNsw"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wNsw"] = (self.d.data["vNsw"].T / self.d.data["vsw"]).T
        if not "wsw" in self.d.data.keys():
            self.d.add_data("wsw", sqrt(self.d.data["wRsw"] ** 2 + self.d.data["wTsw"] ** 2 + self.d.data["wNsw"] ** 2))
        else:
            self.d.data["wsw"] = sqrt(self.d.data["wRsw"] ** 2 + self.d.data["wTsw"] ** 2 + self.d.data["wNsw"] ** 2)

        # _________index 2 in names means vsw speed has been rounded__________
        if not "wRsw2" in self.d.data.keys():
            self.d.add_data("wRsw2", (self.d.data["vRsw2"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wRsw2"] = (self.d.data["vRsw2"].T / self.d.data["vsw"]).T
        if not "wTsw2" in self.d.data.keys():
            self.d.add_data("wTsw2", (self.d.data["vTsw2"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wTsw2"] = (self.d.data["vTsw2"].T / self.d.data["vsw"]).T
        if not "wNsw2" in self.d.data.keys():
            self.d.add_data("wNsw2", (self.d.data["vNsw2"].T / self.d.data["vsw"]).T)
        else:
            self.d.data["wNsw2"] = (self.d.data["vNsw2"].T / self.d.data["vsw"]).T
        if not "wsw2" in self.d.data.keys():
            self.d.add_data("wsw2",
                            sqrt(self.d.data["wRsw2"] ** 2 + self.d.data["wTsw2"] ** 2 + self.d.data["wNsw2"] ** 2))
        else:
            self.d.data["wsw2"] = sqrt(
                self.d.data["wRsw2"] ** 2 + self.d.data["wTsw2"] ** 2 + self.d.data["wNsw2"] ** 2)

        if not "wHe1+2" in self.d.data.keys():
            self.d.add_data("wHe1+2",
                            getvelocity(4., 1., self.d.data["epq"].astype(int)) / around(self.d.data["vsw"], -1))
        else:
            self.d.data["wHe1+2"] = getvelocity(4., 1., self.d.data["epq"].astype(int)) / around(
                self.d.data["vsw"], -1)

    def _add_angles(self):
        '''
        Adds phi and theta angle data products
        :return:
        '''

        # radian values:
        wR = self.d.data['wRsw2']
        wT = self.d.data['wTsw2']
        wN = self.d.data['wNsw2']
        if not "wphi" in self.d.data.keys():
            self.d.add_data("wphi", arctan(wT / wR) + (((sign(wR) - 1) / -2.) * (sign(wT) * pi)))
        else:
            self.d.data["wphi"] = arctan(wT / wR) + (((sign(wR) - 1) / -2.) * (sign(wT) * pi))
        if not "wtheta" in self.d.data.keys():
            self.d.add_data("wtheta", arctan(wN / abs(wR)))
        else:
            self.d.data["wtheta"] = arctan(wN / abs(wR))

        # degree values:
        if not "wphi_deg" in self.d.data.keys():
            self.d.add_data("wphi_deg", (arctan(wT / wR) + (((sign(wR) - 1) / -2.) * (sign(wT) * pi))) * 180. / pi)
        else:
            self.d.data["wphi_deg"] = (arctan(wT / wR) + (((sign(wR) - 1) / -2.) * (sign(wT) * pi)) *180. / pi)
        if not "wtheta_deg" in self.d.data.keys():
            self.d.add_data("wtheta_deg", (arctan(wN / abs(wR)) * 180. / pi))
        else:
            self.d.data["wtheta_deg"] = (arctan(wN / abs(wR)) * 180. / pi)

    def _add_phspeff_wgt(self):
        """
        Loads ion efficiencies
        ion name, mass and charge must be given at the initialisation of the class object
        """
        fin = open("data_misc/%s.eff" % (self.ion), "r")
        dat = loadtxt(fin)
        eff = dat[:, 1]
        if not "eff" in self.d.data.keys():
            self.d.add_data("eff", eff[self.d.data["epq"].astype(int)])
        else:
            self.d.data["eff"] = eff[self.d.data["epq"].astype(int)]
        vs = self.vels[self.d.data["epq"].astype(int)]

        if not "wgteffphsp" in self.d.data.keys():
            self.d.add_data("wgteffphsp", (1. / vs ** 4) / self.d.data["eff"])
        else:
            self.d.data["wgteffphsp"] = (1. / vs ** 4) / self.d.data["eff"]

        #### space volume in km**3 (12s for whole spin, but each sec is only scanned for 1.5s)*solid angle coverage(
        # 4*69 whole)*dv from deltaE/Q*efficiencies
        wgts_all = 1. / (vs * 1.5 * self.geomfac) * 1. / (vs ** 2 * (pi ** 2 / 180 ** 2. * 4. * 69)) * 1. / (
                0.03 * vs) * 1. / self.d.data["eff"]
        #### space volume in km**3 (1.5s for sec)*solid angle coverage(4*33 for sec)*dv from deltaE/Q*efficiencies
        wgts_sec = 1. / (vs * 1.5 * self.geomfac) * 1. / (vs ** 2 * (pi ** 2 / 180 ** 2. * 4. * 23)) * 1. / (
                0.03 * vs) * 1. / self.d.data["eff"]

        if not "wgts_all" in self.d.data.keys():
            self.d.add_data("wgts_all", wgts_all)
        else:
            self.d.data["wgts_all"] = wgts_all
        if not "wgts_sec" in self.d.data.keys():
            self.d.add_data("wgts_sec", wgts_sec)
        else:
            self.d.data["wgts_sec"] = wgts_sec

    def get_norm(self, vswbins=arange(0., 1000.1, 10.), aspphi=(-30., 45.), min_whe=0.0,
                 wbins=arange(-2., 2.01, 0.2), dim=3, frame='sw'):
        '''
        Calculates norm_array for weighting the histogram bins relative to how often a bins has been seen:
        For each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
        to calculate the weights for normalising the final histograms

        :param vswbins: vsw bins over which the normalisation is performed
        :param aspphi: aspphi bins over which the normalisation is performed
        :param min_whe: Lower border for w_He
        :param wbins: bins for the final histogram and also range of the resulting norm_array. Attention: Atm
        wbins are used for all three dimension even with 3D
        :param dim: can be 1 (for spectrum of absolute values) or 3 (for 3D representsation)
        :return: norm_array that is either an 1D or 3D array with the range of wbins in each dimension
        '''
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # find unique time stamps and the resp. AAs and vsw:
        uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
        uasphi = self.d.get_data("Master", "aspphi")[Tallind]
        uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
        uvsw = self.d.get_data("Master", "vsw")[Tallind]
        # H indicates how often a particular aspphi-asptheta-vsw combination occurs (= how often did ULYSSES see this
        # angle with this vsw?)

        # new bins: take the edges again from inbetween the aspphisteps and insert outer borders to not
        # exclude counts
        phibins = arange(self.aspphi[0] - self.aspphistep / 2., self.aspphi[-1] + self.aspthetastep, self.aspphistep)
        thetabins = arange(self.asptheta[0] - self.aspthetastep / 2., self.asptheta[-1] + self.aspthetastep,
                           self.aspthetastep)
        vswbins = arange(self.vswbins[0] - 10 / 2., self.vswbins[-1] + 10, 10)

        H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, phibins, thetabins))
        self.H = H

        # norm_arr indicates how often a wR-wT-wN combination "is hit" with the given AA-vsw combinations and their
        # resp. occurrences
        if dim == 1 or dim == 'x':
            norm_arr = zeros((wbins.shape[0] - 1))
        if dim == 3:
            norm_arr = zeros((wbins.shape[0] - 1, wbins.shape[0] - 1, wbins.shape[0] - 1))

        for iv, v in enumerate(self.vswbins):
            for ip, p in enumerate(self.aspphi):
                if (p >= aspphi[0]) * (p <= aspphi[1]):
                    for it, t in enumerate(self.asptheta):
                        if H[iv, ip, it] > 0:
                            whe = self.vels / (v + 5.)
                            epqs = arange(0, 64, 1)[whe > min_whe]
                            if dim == 3:
                                tmpwx = self.vspace[ip, it, epqs, ..., 0, :] - v
                                wx = tmpwx / v
                                wy = self.vspace[ip, it, epqs, ..., 1, :] / v
                                wz = self.vspace[ip, it, epqs, ..., 2, :] / v

                                H2, bs = histogramdd((wx.flatten(), wy.flatten(), wz.flatten()),
                                                     bins=(wbins, wbins, wbins))
                                norm_arr += H2 * H[iv, ip, it]

                            if dim == 1:
                                tmpwx = self.vspace[ip, it, epqs, ..., 0, :] - v
                                wx = tmpwx / v
                                wy = self.vspace[ip, it, epqs, ..., 1, :] / v
                                wz = self.vspace[ip, it, epqs, ..., 2, :] / v
                                w = sqrt(wx**2 + wy**2 + wz**2)
                                H2, bs = histogram(w.flatten(), bins = wbins)
                                norm_arr += H2 * H[iv, ip, it]
        return norm_arr

    def calc_w3dspecs(self, vswbins=arange(0., 1800.1, 10.), wbins=arange(-2., 2.01, 0.2), min_whe=1,
                      aspphi=(-30., 45.), weights = None):
        """
        Calculates w spectra in slices
        vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
        """
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
        # to calculate the weights for normalising the final histograms:
        norm_arr_sw = self.get_norm(vswbins=vswbins, aspphi=aspphi, min_whe=min_whe, wbins=wbins, dim=3,
                                    frame='sw')

        # consider the PHA words *only now*:
        wgts = self.d.get_data("He1+", "wgts_sec")  # 1 / (phase space volume * eff)
        swgt = self.d.get_data("He1+", "brw")  ### real sector weight not available for Ulysses

        wR_sw2 = self.d.get_data("He1+", "wRsw2")
        wT_sw2 = self.d.get_data("He1+", "wTsw2")
        wN_sw2 = self.d.get_data("He1+", "wNsw2")

        twts = zeros(wR_sw2.shape)
        for i in range(wR_sw2.shape[1]):
            twts[:, i] = swgt * wgts

        self.t = twts

        H2_sw, bs = histogramdd((wR_sw2.flatten(), wT_sw2.flatten(), wN_sw2.flatten()), bins=(wbins, wbins, wbins),
                                weights=twts.flatten())

        self.d.remove_submask("He1+", "wHe1+2")
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        return norm_arr_sw, H2_sw

    def plot_wspec(self, dim='x', slice=10, ax=None, min_wHe=1.0, mode='ps'):
        '''
        :param dim:
        :param slice:
        :param ax:
        :param min_wHe:
        :param mode: Decides whether counts, phase space or norm array are plotted
        :return:
        '''
        wbins = arange(-2, 2.01, 0.2)
        norm_arr, H_0 = self.calc_w3dspecs(min_whe=min_wHe)
        if mode == 'norm':
            H = norm_arr
        elif mode == 'counts':
            H = H_0
        elif mode == 'ps':
            H_0[norm_arr == 0] = 0
            norm_arr[norm_arr == 0] = 1
            H = H_0 / norm_arr
        if ax == None:
            fig, ax = plt.subplots(figsize=(10, 8))
            colormap = plt.cm.get_cmap("viridis")
            vmin = amin(H[H > 0])
            if dim == 'x':
                self.Quadmesh = ax.pcolormesh(wbins, wbins, H[slice, :, :].T, cmap=colormap, vmin=vmin)
                colormap.set_under('white')
                ax.set_xlim(ax.get_xlim()[::-1])
                plane = 'Y-Z'
            elif dim == 'y':
                self.Quadmesh = ax.pcolormesh(wbins, wbins, H[:, slice, :].T, cmap=colormap, vmin=vmin)
                colormap.set_under('white')
                plane = 'X-Z'
            elif dim == 'z':
                self.Quadmesh = ax.pcolormesh(wbins, wbins, H[:, :, slice], cmap=colormap, vmin=vmin)
                colormap.set_under('white')
                plane = 'X-Y'
                ax.set_xlim(ax.get_xlim()[::-1])
            else:
                print('No valid dimension given')
                sys.exit()
            # Text boxes:
            ax.text(0.1, 1.05, '%s-plane' % plane, bbox={"facecolor": "grey", "alpha": 0.4, "pad": 10},
                    transform=ax.transAxes)
            ax.text(0.8, 1.05, r'$\mathrm{w_{sw,%s} = [%2.1f, %2.1f]}$' % (dim, wbins[slice], wbins[slice + 1]),
                    bbox={"facecolor": "grey", "alpha": 0.4, "pad": 10}, transform=ax.transAxes)
            ax.set_xlabel(r'$\mathrm{w_{sw,%s}}$' % plane[0].lower())
            ax.set_ylabel(r'$\mathrm{w_{sw,%s}}$' % plane[-1].lower())
            colorbar = plt.colorbar(self.Quadmesh, ax=ax)

    def hist_sec_det(self, polar=True, binx=arange(0, 4, 1), biny=arange(0, 9, 1)):
        colormap = plt.cm.get_cmap("viridis")
        valsec = self.d.data['sec']
        valdet = self.d.data['det']
        C, bins_det, bins_sec = histogram2d(valdet, valsec, bins=[binx, biny])
        self.C = C
        self.bins_det = bins_det
        self.bins_sec = bins_sec
        if polar == True:
            fig = plt.figure(figsize=(3, 3))
            ax = plt.subplot(111, projection='polar')
            ax.set_ylim(0, 2.8)
            ax.set_yticks([])
            ax.set_theta_zero_location('N')
            ax.set_xticks([x + (2 * pi / 16.) for x in linspace(0, 2 * pi, 8, endpoint=False)])
            ax.set_xticklabels([str(i) for i in arange(0, 8, 1)])
            radbins_sec = linspace(0, 2 * pi, 9)
            fullbins_det = array([3.2, 2, 1, 0])
            Mesh = ax.pcolormesh(radbins_sec, fullbins_det, C, cmap=colormap, norm=colors.LogNorm())
        else:
            fig, ax = plt.subplots()
            ax.set_xlabel('Detector')
            ax.set_xticks(arange(0, 4, 1))
            ax.set_ylabel('Sector')
            ax.set_xticks(arange(0, 9, 1))
            ax.xaxis.set_major_formatter(ticker.NullFormatter())
            ax.xaxis.set_minor_locator(ticker.FixedLocator([0.5, 1.5, 2.5]))
            ax.xaxis.set_minor_formatter(ticker.FixedFormatter(['1', '2', '3']))

            ax.yaxis.set_major_formatter(ticker.NullFormatter())
            ax.yaxis.set_minor_locator(ticker.FixedLocator([0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]))
            ax.yaxis.set_minor_formatter(ticker.FixedFormatter(['0', '1', '2', '3', '4', '5', '6', '7']))

            for tick in ax.xaxis.get_minor_ticks():
                tick.tick1line.set_markersize(0)
                # tick.label1.set_horizontalalignment('center')
            for tick in ax.yaxis.get_minor_ticks():
                tick.tick1line.set_markersize(0)
                # tick.label1.set_horizontalalignment('center')
            Mesh = ax.pcolormesh(bins_det, bins_sec, C.T, cmap=colormap, norm=colors.LogNorm())
        colormap.set_under('white')
        cb = plt.colorbar(Mesh, ax=ax, extend='max')

    def calc_vabs(self, vsw_val=400, doy_val=False):
        '''
        Calculates the absolute |v| from vR, vT and vN to compare it with the solar wind velocity in a small window
        of time
        (Built for comparing the He2+ velocity with SWOOPS' measured vsw)
        '''
        if doy_val == False:
            try:
                self.d.remove_submask('mmask', 'doy')
            except:
                pass
            self.d.set_mask('mmask', 'vsw', vsw_val - 20, vsw_val + 20, reset=True)
        else:
            try:
                self.d.remove_submask('mmask', 'vsw')
            except:
                pass
            self.d.set_mask('mmask', 'doy', doy_val - 0.3, doy_val + 0.3, reset=True)
        vsw = self.d.get_data('mmask', 'vsw').flatten()
        vR = self.d.get_data('mmask', 'vR').flatten()
        vT = self.d.get_data('mmask', 'vT').flatten()
        vN = self.d.get_data('mmask', 'vN').flatten()
        v = sqrt(vR ** 2 + vT ** 2 + vN ** 2)
        fig = plt.figure()
        ax = plt.subplot(111)
        v_bins = arange(200, 1000, 10)
        hist_bulk, bins = histogram(v, bins=v_bins)
        hist_bulk = append(hist_bulk, 0)

        hist_vsw, bins = histogram(tile(vsw, self.sec_det_dim), bins=v_bins)
        hist_vsw = append(hist_vsw, 0)

        ax.plot(bins[:], hist_bulk, ls='steps-post-', color='r', label='calculated bulk velocity')
        ax.plot(bins[:], hist_vsw, ls='steps-post-', color='b', label='SWOOPS solar wind velocity')
        ax.legend()
        return v

    def wspec_1d(self, vswbins = arange(0,1000,10), wbins = arange(-2., 5.01, 0.1), min_whe = 0.0,
                 aspphi = (-30.,45.), mode = 'ps', year = '1993', ax = None):

        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
        # to calculate the weights for normalising the final histograms:

        norm_arr = self.get_norm(vswbins = vswbins, aspphi = aspphi, min_whe = min_whe, wbins = wbins, dim = 1,
                                    frame='sw')

        # consider the PHA words *only now*:
        wgts = self.d.get_data("He1+", "wgts_sec")  # 1 / (phase space volume * eff)
        swgt = self.d.get_data("He1+", "brw")  ### real sector weight not available for Ulysses

        wsw = self.d.get_data('He1+', 'wsw2')  # 1D data in solar wind frame

        twts = zeros(wsw.shape)
        for i in range(wsw.shape[1]):
            twts[:, i] = wgts * swgt

        H0, bs = histogram(wsw.flatten(), bins=wbins, weights=twts.flatten())

        self.d.remove_submask("He1+", "wHe1+2")
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")

        if ax == None:
            fig, ax = plt.subplots(figsize=(12,8))
            ax.set_xlim(-1.05,4)
            ax.xaxis.set_minor_locator(MultipleLocator(.5))
            ax.set_xlabel(r'$\mathrm{w_{sw}}$')
            ax.set_ylabel('phase space density')

        if mode == 'norm':
            H = norm_arr
        elif mode == 'counts':
            H = H0
        elif mode == 'ps':
            H0[norm_arr == 0] = 0
            norm_arr[norm_arr == 0] = 1
            H = H0 / norm_arr
        ax.plot(wbins[:-1], H, ls='steps-post', label='%s'%year)
        ax.legend()
        self.Hw = H
        return ax


    def get_norm_shells(self, vswbins=arange(500., 800.1, 10.), aspphi=(-30., 45.), min_whe=0.0,
                        phirange=[-pi, pi + 0.001], thetarange=[-pi / 2., pi / 2. + 0.001], angstep=10 * pi / 180,
                        wshellbins=
                        arange(0, 2.01, 0.2), vol = True):
        '''
        Calculates norm_array for weighting the histogram bins relative to how often a bins has been seen:
        For each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
        to calculate the weights for normalising the final histograms

        :param vswbins: vsw bins over which the normalisation is performed
        :param aspphi: aspphi bins over which the normalisation is performed
        :param min_whe: Lower border for w_He
        :param wbins: bins for the final histogram and also range of the resulting norm_array. Attention: Atm
        wbins are used for all three dimension even with 3D
        :param dim: can be 1 (for spectrum of absolute values) or 3 (for 3D representation)
        :return: norm_array that is either an 1D or 3D array with the range of wbins in each dimension
        '''
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # find unique time stamps and the resp. AAs and vsw:
        uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
        uasphi = self.d.get_data("Master", "aspphi")[Tallind]
        uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
        uvsw = self.d.get_data("Master", "vsw")[Tallind]
        # H indicates how often a particular aspphi-asptheta-usw combination occurs (= how often did ULYSSES see this
        # angle with this vsw?)

        # new bins: take the edges again from inbetween the aspphisteps and insert outer borders to not
        # exclude counts
        asp_phibins = arange(self.aspphi[0] - self.aspphistep / 2., self.aspphi[-1] + self.aspthetastep,
                             self.aspphistep)
        asp_thetabins = arange(self.asptheta[0] - self.aspthetastep / 2., self.asptheta[-1] + self.aspthetastep,
                               self.aspthetastep)
        vswbins = arange(self.vswbins[0] - 10 / 2., self.vswbins[-1] + 10, 10)

        H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, asp_phibins, asp_thetabins))

        self.H = H

        # norm_arr indicates how often a wR-wT-wN combination "is hit" with the given AA-vsw combinations and their
        # resp. occurrences

        phibins = arange(phirange[0], phirange[1], angstep)
        thetabins = arange(thetarange[0], thetarange[1], angstep)

        self.phibins = phibins
        self.thetabins = thetabins

        norm_arr = zeros((phibins.shape[0] - 1, thetabins.shape[0] - 1, wshellbins.shape[0] - 1))
        for iv, v in enumerate(self.vswbins):
            for ip, p in enumerate(self.aspphi):
                if (p >= aspphi[0]) * (p <= aspphi[1]):
                    for it, t in enumerate(self.asptheta):
                        if H[iv, ip, it] > 0:
                            whe = self.vels / (v + 5.)
                            epqs = arange(0, 64, 1)[whe > min_whe]
                            tmpwR = self.vspace[ip, it, epqs, ..., 0, :] - v
                            wR = tmpwR / v
                            wT = self.vspace[ip, it, epqs, ..., 1, :] / v
                            wN = self.vspace[ip, it, epqs, ..., 2, :] / v

                            wR = wR.flatten()
                            wT = wT.flatten()
                            wN = wN.flatten()
                            w = sqrt(wR ** 2 + wT ** 2 + wN ** 2)

                            wphi = arctan(wT / wR) + (((sign(wR) - 1) / -2.) * (sign(wT) * pi))
                            wtheta = arctan(wN / abs(wR))

                            H2, bs = histogramdd((wphi.flatten(), wtheta.flatten(), w.flatten()),
                                                 bins=(phibins, thetabins, wshellbins))

                            norm_arr += H2 * H[iv, ip, it]

        # consider the different volumes of the bins:
        # 'real' theta in spherical coordinate system goes from 0 to 180 degree:
        thetabins = arange(0., pi + 0.0001, angstep)
        vol_arr = zeros((phibins.shape[0] - 1, thetabins.shape[0] - 1, wshellbins.shape[0] - 1))
        for ip, p in enumerate(phibins[:-1]):
            for it, t in enumerate(thetabins[:-1]):
                for iw, w in enumerate(wshellbins[:-1]):
                    vol_arr[ip, it, iw] = 1 / 3. * (wshellbins[iw + 1] ** 3 - wshellbins[iw] ** 3) * (cos(t) - cos(
                        t + angstep)) * (angstep)
        if vol:
            norm_arr *= vol_arr
        return norm_arr

    def calc_skymapspec(self, vswbins=arange(500., 800.1, 10.), min_whe=1.0, aspphi=(-30., 45.),
                        phirange=[-pi, pi + 0.001], thetarange=[-pi / 2., pi / 2. + 0.001], angstep=10 * pi / 180,
                        wshellbins=arange(0, 2.01, 0.2), vol = True):
        """
        """
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
        self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
        self.d.set_mask("Master", "aspphi", aspphi[0], aspphi[1], reset=True)

        # DOESNT WORK YET
        # norm_arr = ones([len(phibins)-1, len(thetabins)-1, len(wshellbins)-1])
        norm_arr = self.get_norm_shells(vswbins=vswbins, min_whe=min_whe, phirange=phirange, thetarange=
        thetarange, angstep=angstep, wshellbins=wshellbins, vol = vol)

        # consider the PHA words *only now*:
        wgts = self.d.get_data("He1+", "wgts_sec")  # 1 / (phase space volume * eff)
        swgt = self.d.get_data("He1+", "brw")  ### real sector weight not available for Ulysses

        wphi = self.d.get_data("He1+", "wphi")
        wtheta = self.d.get_data("He1+", "wtheta")
        w = self.d.get_data("He1+", "wsw2")

        phibins = arange(phirange[0], phirange[1], angstep)
        thetabins = arange(thetarange[0], thetarange[1], angstep)

        self.wphi = wphi
        self.phibins = phibins

        twts = zeros(wphi.shape)
        for i in range(wphi.shape[1]):
            twts[:, i] = wgts * swgt
        H, bs = histogramdd((wphi.flatten(), wtheta.flatten(), w.flatten()), bins=(phibins, thetabins, wshellbins),
                            weights=twts.flatten())
        self.d.remove_submask("He1+", "wHe1+2")
        self.d.remove_submask("Master", "vsw")
        self.d.remove_submask("Master", "aspphi")
        self.d.remove_submask("Master", "asptheta")
        return norm_arr, H

    def plot_shellspec(self, shell = 5, ax = None, min_wHe = 0.9, phirange=[-pi, pi + 0.001],
                                            thetarange=[-pi / 2., pi / 2. + 0.001], angstep= 30 * pi / 180.,
                                            wshellbins=arange(0, 2.01, 0.2), mode='ps', vol = True):

        norm_arr, H0 = self.calc_skymapspec(min_whe = min_wHe, phirange = phirange,
                 thetarange = thetarange, angstep = angstep, wshellbins = wshellbins, vol = vol)

        if mode == 'norm':
            H = norm_arr
        elif mode == 'counts':
            H = H0
        elif mode == 'ps':
            H0[norm_arr == 0] = 0
            norm_arr[norm_arr == 0] = 1
            H = H0 / norm_arr
        self.H = H

        # bins that are shown in the plot. Have to have the dimension of the histogram.
        phibins = arange(-180., 180.1, angstep * 180. / pi)
        thetabins = arange(-90., 90.1, angstep * 180. / pi)

        colormap = plt.cm.get_cmap("viridis")
        try:
            vmin = amin(H[:, :, shell][H[:, :, shell] > 0])
        except:
            vmin = 0.
        vmax = amax(H[:, :, shell])
        if vmax < 1.:
            vmax = 10.

        if ax == None:
            fig, ax = plt.subplots(figsize=(10, 8))
            colormap = plt.cm.get_cmap("viridis")
            self.Quadmesh = ax.pcolormesh(phibins, thetabins, H[:, :, shell].T, cmap=colormap, vmin=vmin, vmax=vmax)
            colorbar = plt.colorbar(self.Quadmesh, ax=ax)
            colormap.set_under('white')
            ax.text(0.05, 1.05, 'Shell: %s' % shell, bbox={"facecolor": "grey", "alpha": 0.4, "pad": 10},
                    transform=ax.transAxes)
            ax.text(0.6, 1.05, r'$\mathrm{w_{sw} = [%2.1f, %2.1f]}$' % (wshellbins[shell], wshellbins[shell + 1]),
                    bbox={"facecolor": "grey", "alpha": 0.4, "pad": 10}, transform=ax.transAxes)
        return H



    def plot_skyspec(self, shell = 5, ax = None, min_wHe = 0.9, phirange=[-pi, pi + 0.001],
                                            thetarange=[-pi / 2., pi / 2. + 0.001], angstep= 30 * pi / 180.,
                                            wshellbins=arange(0, 2.01, 0.2), mode='ps', vol = True):

        norm_arr, H0 = self.calc_skymapspec(min_whe = min_wHe, phirange = phirange,
                 thetarange = thetarange, angstep = angstep, wshellbins = wshellbins, vol = vol)

        if mode == 'norm':
            H = norm_arr
        elif mode == 'counts':
            H = H0
        elif mode == 'ps':
            H0[norm_arr == 0] = 0
            norm_arr[norm_arr == 0] = 1
            H = H0 / norm_arr
        self.H = H

        # bins that are shown in the plot. Have to have the dimension of the histogram.
        phibins = arange(-pi, pi + 0.001, angstep)
        thetabins = arange(-pi/2., pi/2. + 0.0001, angstep)

        # phibins = arange(-180., 180.1, angstep * 180. / pi)
        # thetabins = arange(-90., 90.1, angstep * 180. / pi)

        colormap = plt.cm.get_cmap("viridis")
        try:
            vmin = amin(H[:, :, shell][H[:, :, shell] > 0])
        except:
            vmin = 0.
        vmax = amax(H[:, :, shell])
        if vmax < 1.:
            vmax = 10.

        if ax == None:
            plt.figure()
            ax = plt.subplot(111, projection="mollweide")
            #fig, ax = plt.subplots(figsize=(10, 8), projection = 'hammer')
            colormap = plt.cm.get_cmap("viridis")
            self.Quadmesh = ax.pcolormesh(phibins, thetabins, H[:, :, shell].T, cmap=colormap, vmin=vmin, vmax=vmax)
            colorbar = plt.colorbar(self.Quadmesh, ax=ax, shrink = 0.8)
            ax.set_xlabel(r'$\varphi \, / \, \degree$')
            ax.set_ylabel(r'$\vartheta \, / \, \degree$')
            ax.grid()
            colormap.set_under('white')
            ax.text(0.05, 1.5, 'Shell: %s' % shell, bbox={"facecolor": "grey", "alpha": 0.4, "pad": 10},
                    transform=ax.transAxes)
            ax.text(0.6, 1.5, r'$\mathrm{w_{sw} = [%2.1f, %2.1f]}$' % (wshellbins[shell], wshellbins[shell + 1]),
                    bbox={"facecolor": "grey", "alpha": 0.4, "pad": 10}, transform=ax.transAxes)
        #return H



    def test_func(self, norm, H):
        # for testing if the norm array covers every bin of the H array (which should be the case!)
        wbins = arange(-2., 2.01, 0.2)
        norm_p = norm.sum(axis=0)
        H_p = H.sum(axis=0)
        colormap = plt.cm.get_cmap("viridis")
        vmin = amin(H_p[H_p > 0])
        H_p[norm_p != 0] = 0.
        print(unique(H_p))

        fig, ax = plt.subplots(figsize=(10, 8))
        ax.set_title('H')
        Quadmesh = ax.pcolormesh(wbins, wbins, H_p, vmin=vmin)
        plt.colorbar(Quadmesh, ax=ax)

        fign, axn = plt.subplots(figsize=(10, 8))
        axn.set_title('norm')
        Quadmeshn = axn.pcolormesh(wbins, wbins, norm_p, vmin=vmin)
        plt.colorbar(Quadmeshn, ax=axn)
        colormap.set_under('white')

    def plot_diff(self, axR=None):
        # mit Rundung aus Vspace
        wRsw2 = self.d.get_data("Master", "wRsw2")
        wTsw2 = self.d.get_data("Master", "wTsw2")
        wNsw2 = self.d.get_data("Master", "wNsw2")

        # ohne Rundung aus vSpace
        wRsw = self.d.get_data("Master", "wRsw")
        wTsw = self.d.get_data("Master", "wTsw")
        wNsw = self.d.get_data("Master", "wNsw")

        # aus wSpace, also ohne Beruecksichtigung der Eigengeschwindigkeit
        wR_s = self.d.get_data("Master", "wR_s")
        wT_s = self.d.get_data("Master", "wT_s")
        wN_s = self.d.get_data("Master", "wN_s")

        x = range(len(wRsw2))
        if axR == None:
            fig, axR = plt.subplots()
        axR.plot(x, wRsw2, '.', label="sw2")
        # axR.plot(x, wRsw, '.', label="sw1")
        axR.plot(x, wR_s, '.', label="sw_s")
        axR.legend()
        print(mean(wRsw2 - wR_s))
        return axR



        # ____________________ standard plot functions _____________________

    def plot_wspace(self, ax=None, vsw=0, aspphi=0, asptheta=0, epq=30, sec='all'):
        if ax == None:
            fig = plt.figure(figsize=(6, 6))
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('W-Space')
            # ax.set_title('W-Space')
            ax.set_xlim(-2.5, 2.5)
            ax.set_ylim(-2.5, 2.5)
            ax.set_zlim(-2.5, 2.5)
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            w = self.w3dspace[vsw, aspphi, asptheta, epq, :, sec, :, :]
            nrs = w.shape[-2] * w.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(w[..., 0, :], w[..., 1, :], w[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            w = self.w3dspace[vsw, aspphi, asptheta, epq, :, :, :, :]
            for i, s in enumerate(range(w.shape[-3])):
                nrs = w.shape[-2] * w.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(w[..., s, 0, :], w[..., s, 1, :], w[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax

    def plot_vspace(self, ax=None, aspphi=-1, asptheta=-1, epq=50, sec='all'):
        if ax == None:
            fig = plt.figure(figsize=(6, 6))
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('V-Space')
            # ax.set_title('W-Space')
            ax.set_xlim(-600, 600)
            ax.set_ylim(-600, 600)
            ax.set_zlim(-600, 600)
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            v = self.vspace[aspphi, asptheta, epq, :, sec, :, :]
            nrs = v.shape[-2] * v.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(v[..., 0, :], v[..., 1, :], v[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 600], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            v = self.vspace[aspphi, asptheta, epq, :, :, :, :]
            for i, s in enumerate(range(v.shape[-3])):
                nrs = v.shape[-2] * v.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(v[..., s, 0, :], v[..., s, 1, :], v[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 600], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax

    def plot_FoV(self, ax=None, aspphi=0, asptheta=0, sec='all'):
        if ax == None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('FoV')
            # ax.set_title('FoV')
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            f = self.FoV[aspphi, asptheta, :, sec, :, :]
            nrs = f.shape[-2] * f.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(f[..., 0, :], f[..., 1, :], f[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            f = self.FoV[aspphi, asptheta, :, :, :, :]
            for i, s in enumerate(range(f.shape[-3])):
                nrs = f.shape[-2] * f.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(f[..., s, 0, :], f[..., s, 1, :], f[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax


    def draw_sphere(self, ax = None, r = 1.):
        u, v = mgrid[0:2 * pi:20j, 0:pi:10j]
        x = r *cos(u) * sin(v) + r
        y = r* sin(u) * sin(v)
        z = r * cos(v)
        ax.plot_wireframe(x, y, z, color="r")

# # _________________ not used atm ________________________________
#
#
#     def _calc_pitchangle(self):
#         # recalc abs(B)
#         absB = sqrt(self.d.data["Bx"] ** 2 + self.d.data["By"] ** 2 + self.d.data["Bz"] ** 2)
#         # Calculate unit Vector along B-field
#         if not "eBx" in self.d.data.keys():
#             self.d.add_data("eBx", self.d.data["Bx"] / absB)
#         else:
#             self.d.data["eBx"] = self.d.data["Bx"] / absB
#         if not "eBy" in self.d.data.keys():
#             self.d.add_data("eBy", self.d.data["By"] / absB)
#         else:
#             self.d.data["eBy"] = self.d.data["By"] / absB
#         if not "eBz" in self.d.data.keys():
#             self.d.add_data("eBz", self.d.data["Bz"] / absB)
#         else:
#             self.d.data["eBz"] = self.d.data["Bz"] / absB
#         # Calculate unit Vector along w vector in solar wind frame
#         if not "ewR" in self.d.data.keys():
#             self.d.add_data("ewR", self.d.data["wRsw"] / self.d.data["wsw"])
#         else:
#             self.d.data["ewR"] = self.d.data["wRsw"] / self.d.data["wsw"]
#         if not "ewT" in self.d.data.keys():
#             self.d.add_data("ewT", self.d.data["wTsw"] / self.d.data["wsw"])
#         else:
#             self.d.data["ewT"] = self.d.data["wTsw"] / self.d.data["wsw"]
#         if not "ewN" in self.d.data.keys():
#             self.d.add_data("ewN", self.d.data["wNsw"] / self.d.data["wsw"])
#         else:
#             self.d.data["ewN"] = self.d.data["wNsw"] / self.d.data["wsw"]
#         # Calculate cosine of pitch angle mu by scalar product of eB and and ew.
#         # Cosmup stands for B-field is still important,i.e. inward field cosmup=1 means the opposite direction
#         # compared to the solar wind bulk than for outward polarity!
#         if not "cosmup" in self.d.data.keys():
#             self.d.add_data("cosmup",
#                             self.d.data["eBx"] * self.d.data["ewR"] + self.d.data["eBy"] * self.d.data["ewT"] +
#                             self.d.data["eBz"] * self.d.data["ewN"])
#         else:
#             self.d.data["cosmup"] = self.d.data["eBx"] * self.d.data["ewR"] + self.d.data["eBy"] * self.d.data["ewT"]\
#                                     + \
#                                     self.d.data["eBz"] * self.d.data["ewN"]
#         # Cosmu is the cosine on the outward projected B field, i.e. if the polarity is inward cosmu 1 is now
#         # pointing away from the Sun
#         if not "cosmu" in self.d.data.keys():
#             self.d.add_data("cosmu", self.d.data["cosmup"])
#         else:
#             self.d.data["cosmu"] = self.d.data["cosmup"]
#         # inmask very brutally assumes each polarity to be separated in hemispheres (out -45(~parker angle)+-90
#         # degree -> in 135+-90 degree)
#         inmask = ~((self.d.data["Bphi"] > -135) * (self.d.data["Bphi"] < 45))
#         self.d.data["cosmu"][inmask] = -self.d.data["cosmu"][inmask]
#
#     def _calc_sw_bulk_properties(self):
#         """
#         Calculate the solar wind Bulk vector, assuming that the proton core is shifted along B by the alfven speed
#         from the radial axis
#         """
#         # Add alfven speed
#         if not "valf" in self.d.data.keys():
#             self.d.add_data("valf", 21.8 * self.d.data["B"] / sqrt(self.d.data["dsw"]))
#         else:
#             self.d.data["valf"] = 21.8 * self.d.data["B"] / sqrt(self.d.data["dsw"])
#         vswT = self.d.data["valf"] * self.d.data["eBy"]
#         vswN = self.d.data["valf"] * self.d.data["eBz"]
#         phi = self.d.data["Bphi"]
#         vswT[(phi > -135) * (phi < 45)] *= -1.
#         vswN[(phi > -135) * (phi < 45)] *= -1.
#         vswR = sqrt(self.d.data["vsw"] ** 2 - vswT ** 2 - vswN ** 2)
#         if not "vswR" in self.d.data.keys():
#             self.d.add_data("vswR", vswR)
#         else:
#             self.d.data["vswR"] = vswR
#         if not "vswT" in self.d.data.keys():
#             self.d.add_data("vswT", vswT)
#         else:
#             self.d.data["vswT"] = vswT
#         if not "vswN" in self.d.data.keys():
#             self.d.add_data("vswN", vswN)
#         else:
#             self.d.data["vswN"] = vswN
#         if not "vRswa" in self.d.data.keys():
#             self.d.add_data("vRswa", self.d.data["vR"] - vswR)
#         else:
#             self.d.data["vRswa"] = self.d.data["vR"] - vswR
#         if not "vTswa" in self.d.data.keys():
#             self.d.add_data("vTswa", self.d.data["vT"] - vswT)
#         else:
#             self.d.data["vTswa"] = self.d.data["vT"] - vswT
#         if not "vNswa" in self.d.data.keys():
#             self.d.add_data("vNswa", self.d.data["vN"] - vswN)
#         else:
#             self.d.data["vNswa"] = self.d.data["vN"] - vswN
#         if not "wRswa" in self.d.data.keys():
#             self.d.add_data("wRswa", self.d.data["vRswa"] / self.d.data["vsw"])
#         else:
#             self.d.data["wRswa"] = self.d.data["vRswa"] / self.d.data["vsw"]
#         if not "wTswa" in self.d.data.keys():
#             self.d.add_data("wTswa", self.d.data["vTswa"] / self.d.data["vsw"])
#         else:
#             self.d.data["wTswa"] = self.d.data["vTswa"] / self.d.data["vsw"]
#         if not "wNswa" in self.d.data.keys():
#             self.d.add_data("wNswa", self.d.data["vNswa"] / self.d.data["vsw"])
#         else:
#             self.d.data["wNswa"] = self.d.data["vNswa"] / self.d.data["vsw"]
#         if not "wswa" in self.d.data.keys():
#             self.d.add_data("wswa",
#                             sqrt(self.d.data["wRswa"] ** 2 + self.d.data["wTswa"] ** 2 + self.d.data["wNswa"] ** 2))
#         else:
#             self.d.data["wswa"] = sqrt(
#                 self.d.data["wRswa"] ** 2 + self.d.data["wTswa"] ** 2 + self.d.data["wNswa"] ** 2)
#
#     def calc_wspec_norm(self, vsws=arange(495., 800., 10.), wbins=arange(-1., 5.1, .1), min_whe=0.9):
#         """
#         Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
#         vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
#         """
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
#         # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
#         #  to calculate the weights for normalising the final histograms.
#         norm_arr = zeros((wbins.shape[0] - 1))
#         cts_arr = zeros((wbins.shape[0] - 1))
#         for v in vsws.astype(int):
#             self.d.set_mask("Master", "vsw", v, v + 10., reset=True)
#             for phi in self.aspphi[:-1]:
#                 self.d.set_mask("Master", "aspphi", phi - 0.5, phi + 0.5, reset=True)
#                 for theta in self.asptheta[:-1]:
#                     self.d.set_mask("Master", "asptheta", theta - 0.5, theta + 0.5, reset=True)
#                     # All times (after Master mask) under which particles could have been measured under given aspect
#                     #  angle and solar wind speed
#                     uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
#                     if uTall.shape[0] == 0.:
#                         pass
#                     else:
#                         phiind = searchsorted(self.aspphi, phi)
#                         thetaind = searchsorted(self.asptheta, theta)
#                         whe = self.vels[1] / (v + 5.)
#                         epqs = arange(0, 60, 1)[whe > min_whe]
#                         wspace = self.vspace[phiind, thetaind, epqs]
#                         wspace[:, :, :, 0, :] -= (v + 5.)
#                         wspace /= (v + 5.)
#                         wcov = sqrt(sum(wspace ** 2, axis=3))
#                         wcov[wspace[:, :, :, 0, :] < 0] *= -1.
#                         H, xbins = histogram(wcov.flatten(), bins=wbins)
#                         norm_arr += H * uTall.shape[0]
#                         wgts = self.d.get_data("He1+", "wgts_sec")
#                         ws = self.d.get_data("He1+", "wsw2")
#                         wRsw = self.d.get_data("He1+", "wRsw2")
#                         ws[wRsw < 0] *= -1.
#                         swgt = self.d.get_data("He1+", "swt")
#                         H, xbins = histogram(ws, bins=wbins, weights=wgts * swgt)
#                         cts_arr += H
#         self.d.remove_submask("He1+", "wHe1+2")
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         return cts_arr, norm_arr
#
#     def calc_muspec(self, vsws=arange(495., 800., 10.), wbins=arange(0., 5.1, .1), min_whe=0.9, bphi=90., btheta=0.,
#                     dbphi=10., dbtheta=10., cosmubins=arange(-1., 1.01, .1)):
#         """
#         Calculates pitch-angle over w spectra. Data preselected by Master mask.
#         vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
#         """
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.remove_submask("Master", "Bphi")
#         self.d.remove_submask("Master", "Btheta")
#         self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
#         self.d.set_mask("Master", "Bphi", bphi - dbphi, bphi + dbphi, reset=True)
#         self.d.set_mask("Master", "Btheta", btheta - dbtheta, btheta + dbtheta, reset=True)
#         # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
#         #  to calculate the weights for normalising the final histograms.
#         norm_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
#         cts_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
#         B0 = array([1., 0., 0.])
#         rphiax = array([0., 0., 1.])
#         rthetaax = rotate(array([0., 1., 0]), rphiax, bphi, deg=True)
#         B = rotate(B0, rphiax, bphi, deg=True)
#         B = rotate(B, rthetaax, btheta, deg=True)
#
#         for v in vsws.astype(int):
#             self.d.set_mask("Master", "vsw", v, v + 10., reset=True)
#             for phi in self.aspphi[:-1]:
#                 self.d.set_mask("Master", "aspphi", phi - 0.5, phi + 0.5, reset=True)
#                 for theta in self.asptheta[:-1]:
#                     self.d.set_mask("Master", "asptheta", theta - 0.5, theta + 0.5, reset=True)
#                     # All times (after Master mask) under which particles could have been measured under given aspect
#                     #  angle and solar wind speed
#                     uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
#                     if uTall.shape[0] == 0.:
#                         pass
#                     else:
#                         phiind = searchsorted(self.aspphi, phi)
#                         thetaind = searchsorted(self.asptheta, theta)
#                         whe = self.vels[1] / (v + 5.)
#                         epqs = arange(0, 60, 1)[whe > min_whe]
#                         wspace = self.vspace[phiind, thetaind, epqs]
#                         wspace[:, :, :, 0, :] -= (v + 5.)
#                         wspace /= (v + 5.)
#                         wcov = sqrt(sum(wspace ** 2, axis=3))
#                         ewspace = 1. * wspace
#                         ewspace[:, :, :, 0] = wspace[:, :, :, 0] / wcov[:, :, :]
#                         ewspace[:, :, :, 1] = wspace[:, :, :, 1] / wcov[:, :, :]
#                         ewspace[:, :, :, 2] = wspace[:, :, :, 2] / wcov[:, :, :]
#                         cosmu = ewspace[:, :, :, 0, :] * B[0] + ewspace[:, :, :, 1, :] * B[1] + ewspace[:, :, :, 2,
#                                                                                                 :] * \
#                                 B[2]
#                         H, xbins, ybins = histogram2d(wcov.flatten(), cosmu.flatten(), bins=(wbins, cosmubins))
#                         norm_arr += H * uTall.shape[0]
#                         wgts = self.d.get_data("He1+", "wgts_sec")
#                         ws = self.d.get_data("He1+", "wsw2")
#                         wRsw = self.d.get_data("He1+", "wRsw2")
#                         cmu = self.d.get_data("He1+", "cosmu")
#                         swgt = self.d.get_data("He1+", "swt")
#                         H, xbins, ybins = histogram2d(ws, cmu, bins=(wbins, cosmubins), weights=wgts * swgt)
#                         cts_arr += H
#         self.d.remove_submask("He1+", "wHe1+2")
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.remove_submask("Master", "Bphi")
#         self.d.remove_submask("Master", "Btheta")
#         return cts_arr, norm_arr, xbins, ybins
#
#     def calc_wpecs2(self, vswbins=arange(500., 800.1, 10.), wbins=arange(-1., 2.01, 0.1), min_whe=0.9):
#         """
#         Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
#         vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
#         """
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
#         # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
#         #  to calculate the weights for normalising the final histograms.
#         norm_arr = zeros((wbins.shape[0] - 1))
#         cts_arr = zeros((wbins.shape[0] - 1))
#         self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
#         # self.d.set_mask("Master","wRsw",0.,10000,reset=True)
#         uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
#         uasphi = self.d.get_data("Master", "aspphi")[Tallind]
#         uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
#         uvsw = self.d.get_data("Master", "vsw")[Tallind]
#         H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, self.aspphi, self.asptheta))
#         ivoffset = int(around(vswbins[0] - 300, -1) / 10)
#         for iv, v in enumerate(vswbins[:-1]):
#             for ip, p in enumerate(self.aspphi[:-1]):
#                 for it, t in enumerate(self.asptheta[:-1]):
#                     if H[iv, ip, it] > 0:
#                         whe = self.vels / (v + 5.)
#                         epqs = arange(0, 60, 1)[whe > min_whe]
#                         mask = self.w3dspace[iv + ivoffset, ip, it, epqs, :, :, 0, 0] < 0
#                         wspace = self.wspace[iv + ivoffset, ip, it, epqs]
#                         wspace[mask] *= -1.
#                         # H2,xb = histogram(self.wspace[iv,ip,it,epqs][mask],bins=wbins)
#                         H2, xb = histogram(wspace, bins=wbins)
#                         norm_arr += H2 * H[iv, ip, it]
#         wgts = self.d.get_data("He1+", "wgts_sec")
#         swgt = self.d.get_data("He1+", "swt")
#         ws = self.d.get_data("He1+", "wsw2")
#         wRsw = self.d.get_data("He1+", "wRsw2")
#         ws[wRsw < 0] *= -1.
#         H2, xb = histogram(ws, bins=wbins, weights=wgts * swgt)
#         self.d.remove_submask("He1+", "wHe1+2")
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         return norm_arr, H2
#
#     def calc_cosmuspecs(self, vswbins=arange(500., 800.1, 10.), cosmubins=arange(-1., 1.01, .2),
#                         wbins=arange(-0., 2.1, .2), min_whe=0.9, bphibins=arange(-110, -69.9, 10.),
#                         bthetabins=arange(-20, 20.1, 10.)):
#         """
#         Calculates w spectra. Data preselected by Master mask, i.e. Magnetic field direction.
#         vsws -> bins for solar wind speed that are taken to calculate the instrumental coverage at w-bins
#         """
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         self.d.set_mask("He1+", "wHe1+2", min_whe, 10., reset=True)
#         # for each combination of aspect angles and solar wind velocity the phase space coverage has to be calculated
#         #  to calculate the weights for normalising the final histograms.
#         norm_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
#         cts_arr = zeros((wbins.shape[0] - 1, cosmubins.shape[0] - 1))
#         ivoffset = int(around(vswbins[0] - 500, -1) / 10)
#         self.d.set_mask("Master", "vsw", vswbins[0], vswbins[-1], reset=True)
#         for iphi, bphi in enumerate(bphibins[:-1]):
#             for itheta, btheta in enumerate(bphibins[:-1]):
#                 self.d.set_mask("Master", "Bphi", bphi, bphibins[iphi + 1], reset=True)
#                 self.d.set_mask("Master", "Btheta", btheta, bthetabins[iphi + 1], reset=True)
#                 uTall, Tallind = unique(self.d.get_data("Master", "d00"), return_index=True)
#                 uasphi = self.d.get_data("Master", "aspphi")[Tallind]
#                 uasptheta = self.d.get_data("Master", "asptheta")[Tallind]
#                 uvsw = self.d.get_data("Master", "vsw")[Tallind]
#                 H, bs = histogramdd((uvsw, uasphi, uasptheta), bins=(vswbins, self.aspphi, self.asptheta))
#                 B0 = array([1., 0., 0.])
#                 rphiax = array([0., 0., 1.])
#                 rthetaax = rotate(array([0., 1., 0]), rphiax, bphi + 5, deg=True)
#                 B = rotate(B0, rphiax, bphi + 5, deg=True)
#                 B = rotate(B, rthetaax, btheta + 5, deg=True)
#                 for iv, v in enumerate(vswbins[:-1]):
#                     for ip, p in enumerate(self.aspphi[:-1]):
#                         for it, t in enumerate(self.asptheta[:-1]):
#                             if H[iv, ip, it] > 0:
#                                 whe = self.vels / (v + 5.)
#                                 epqs = arange(0, 60, 1)[whe > min_whe]
#                                 w3dspace = self.w3dspace[iv + ivoffset, ip, it, epqs]
#                                 wspace = self.wspace[iv + ivoffset, ip, it, epqs]
#                                 w3dspace[..., 0, 0] /= wspace[..., 0, 0]
#                                 w3dspace[..., 1, 0] /= wspace[..., 0, 0]
#                                 w3dspace[..., 2, 0] /= wspace[..., 0, 0]
#                                 cosmuspace = w3dspace[..., 0, 0] * B[0] + w3dspace[..., 1, 0] * B[1] + w3dspace[
#                                     ..., 2, 0] * B[2]
#                                 H2, xb, yb = histogram2d(wspace.flatten(), cosmuspace.flatten(),
#                                                          bins=(wbins, cosmubins))
#                                 norm_arr += H2 * H[iv, ip, it]
#         self.d.set_mask("Master", "Bphi", bphibins[0], bphibins[-1], reset=True)
#         self.d.set_mask("Master", "Btheta", bthetabins[0], bthetabins[-1], reset=True)
#         wgts = self.d.get_data("He1+", "wgts_sec")
#         swgt = self.d.get_data("He1+", "swt")
#         wsw2 = self.d.get_data("He1+", "wsw2")
#         cosmu = self.d.get_data("He1+", "cosmu")
#         H2, xb, yb = histogram2d(wsw2, cosmu, bins=(wbins, cosmubins), weights=(wgts * swgt))
#         self.d.remove_submask("Master", "Bphi")
#         self.d.remove_submask("Master", "Btheta")
#         self.d.remove_submask("He1+", "wHe1+2")
#         self.d.remove_submask("Master", "vsw")
#         self.d.remove_submask("Master", "aspphi")
#         self.d.remove_submask("Master", "asptheta")
#         return norm_arr, H2
#
#     def plot_stuff(self, H, wRbins, wTbins, wNbins):
#         """
#         Just from ipython shell ... will be done next time
#         """
#         fig = figure()
#         for i in range(0, 9):
#             fig.add_subplot("33%i" % (i + 1))
#             ax = fig.gca()
#             sli = H[i + 9]
#             sli /= amax(sli)
#             ax.pcolormesh(wbins, wbins, sli.T, cmap="jet", vmax=1.)
