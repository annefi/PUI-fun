from swics_collimator_ulysses import collimator
from DataLoader.uswiutils import getvelocity
from ACE.tools.ace_utils import calc_day00
from pylib.etCoord import rotate
from numpy import *
import matplotlib.pyplot as plt
from custom_colours import lighten_color
import matplotlib.colors as colors
import matplotlib.ticker as ticker
import sys
import matplotlib
import time
from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,
                               AutoMinorLocator)

matplotlib.rcParams.update({'font.size': 18,
                            'xtick.major.size': 13,
                            'xtick.major.width': 2,
                            'xtick.minor.size': 8,
                            'xtick.minor.width': 1,
                            'ytick.major.size': 13,
                            'ytick.major.width': 2,
                            'ytick.minor.size': 8,
                            'ytick.minor.width': 1})


class Plot_wspace(object):
    '''
    Class for plotting FoV, vspace or wspace with a reduced number of dtector points. Works on an uswipha instance
    and used the resp. bins for vsw, aspphi, asptheta
    '''
    def __init__(self, d, mass=4., charge=1., aspphistep=2., aspthetastep=2., v_sc_step=1., nrs_perp=2, nrs_para=3,
                 nrs_sec=3, nrs_epq=1, vswstep = 10, ion="He1+", offset_sp=180., sc_vel=True):

        # nrs_perp: 3, nrs_para: 9, nrs_sec: 6, nrs_epq: 3
        """
        d : dbData instance with species predifined by Master mask
        m : Ion mass in amu
        q : Ion charge in e
        """
        self.d = d
        self.aspphistep = aspphistep
        self.aspthetastep = aspthetastep
        self.nrs_para = nrs_para
        self.nrs_perp = nrs_perp
        self.nrs_sec = nrs_sec
        self.nrs_epq = nrs_epq
        self.vswstep = vswstep
        self.mass = mass
        self.charge = charge
        self.ion = ion
        self.sc_vel = sc_vel
        self.offset_sp = offset_sp
        self.col_dim = self.nrs_para * self.nrs_perp * self.nrs_sec
        self.sec_det_dim = self.col_dim * self.nrs_epq
        self.aspphi = arange(around(min(self.d.data["aspphi"])),
                             around(max(self.d.data["aspphi"])) + aspphistep + 0.0001, aspphistep)
        self.asptheta = arange(around(min(self.d.data["asptheta"])),
                               around(max(self.d.data["asptheta"])) + aspthetastep + 0.0001, aspthetastep)

        self.vswbins = arange(around(min(self.d.data["vsw"]), decimals=-1),
                              around(max(self.d.data["vsw"]), decimals=-1) + vswstep + 0.0001, vswstep)

        self.vr = arange(around(min(self.d.data["vr_sc"])),
                         around(max(self.d.data["vr_sc"])) + v_sc_step + 0.0001, v_sc_step)
        self.vt = arange(around(min(self.d.data["vt_sc"])),
                         around(max(self.d.data["vt_sc"])) + v_sc_step + 0.0001, v_sc_step)
        self.vn = arange(around(min(self.d.data["vn_sc"])),
                         around(max(self.d.data["vn_sc"])) + v_sc_step + 0.0001, v_sc_step)

        self.vels = getvelocity(self.mass, self.charge, arange(0, 64, 1), frac=1.)
        # nrs_epq -> deltaEpQ is +-5% -> delta v is +-2.5% -> nrs_epq equal spaced velocities in epq direction are
        # generated by vels_fac
        self.vels_fac = linspace(0.975 + 0.025 / self.nrs_epq, 1.025 - 0.025 / self.nrs_epq, self.nrs_epq)
        if not "d00" in self.d.data.keys():
            self.d.add_data("d00", calc_day00(self.d.data["year"], self.d.data["doy"]))
        else:
            self.d.data["d00"] = calc_day00(self.d.data["year"], self.d.data["doy"])
        self.geomfac = 0.0225 * 1e-10
        # depends on max vsw, here in SC frame
        self.wshellmax = getvelocity(self.mass, self.charge, 0, frac = 1.) / max(self.d.data["vsw"])

        self._calc_FoV()
        self._calc_vspace()
        print('*** calc w space ***')
        self._calc_wspace()


    def _calc_FoV(self):
        # shape self.FoV: (#aspphi, #asptheta, #det, #sec, xyz, col_dim)
        # (col_dim is nrs_para * nrs_perp * nrs_sec)
        self.FoV = zeros((self.aspphi.shape[0], self.asptheta.shape[0], 3, 8, 3, self.col_dim))
        for iphi, phi in enumerate(self.aspphi):
            for itheta, theta in enumerate(self.asptheta):
                c = collimator(aspphi=phi, asptheta=theta, nrs_perp=self.nrs_perp, nrs_para=self.nrs_para,
                               nrs_sec=self.nrs_sec, offset_sp=self.offset_sp)
                self.FoV[iphi, itheta] = c.FoV

    def _calc_vspace(self):
        """
        Calculates vR,vT,vN for all epqsteps and given aspect angles.
        shape self.vspace: (#aspphi, #asptheta, #vr, #vt, #vn, #epq-steps, #det, #sec, xyz, sec_det_dim)
        (sec_det_dim is col_dim * nrs_epq)
        """
        self.vspace = zeros((self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))
        for i in range(self.nrs_epq):
            for iv, v in enumerate(self.vels):
                self.vspace[:, :, iv, :, :, :, i * self.col_dim:(i + 1) * self.col_dim] = -self.FoV * v * \
                                                                                          self.vels_fac[i]

        self.vspace[:, :, :, :, :, 0, :] = -self.vspace[:, :, :, :, :, 0, :]  # R defined positive from Sun to SC
        self.vspace[:, :, :, :, :, 1, :] = -self.vspace[:, :, :, :, :, 1, :]  # positive T in the regular definition

    def _calc_wspace(self):
        """
        Calculates vR,vT,vN for all epqsteps and given aspect angles
        """

        self.w3dspace = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))

        self.wspace = zeros(
            (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 1, self.sec_det_dim))

        # self.w3dspace_sc = zeros(
        #     (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 3, self.sec_det_dim))
        # self.wspace_sc = zeros(
        #     (self.vswbins.shape[0], self.aspphi.shape[0], self.asptheta.shape[0], 64, 3, 8, 1, self.sec_det_dim))
        for iv, v in enumerate(self.vswbins[:-1]):
            tmpspace = 1. * self.vspace
            tmpspace[..., 0, :] -= (v)
            tmpspace /= (v)
            self.w3dspace[iv, ...] = tmpspace
            self.wspace[iv, ..., 0, :] = sqrt(sum(tmpspace ** 2, axis=5))
            print(iv)

            ## SC frame:
            # tmpspace_sc = 1. * self.vspace
            # tmpspace_sc /= v
            # self.w3dspace_sc[iv, ...] = tmpspace_sc
            # self.wspace_sc[iv, ..., 0, :] = sqrt(sum(tmpspace_sc ** 2, axis=5))

        # ____________________ standard plot functions _____________________

    def plot_wspace(self, ax=None, vsw=0, aspphi=0, asptheta=0, epq=10, sec='all'):
        if ax == None:
            fig = plt.figure(figsize=(6, 6))
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('W-Space')
            # ax.set_title('W-Space')
            ax.set_xlim(-2.5, 2.5)
            ax.set_ylim(-2.5, 2.5)
            ax.set_zlim(-2.5, 2.5)
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            w = self.w3dspace[vsw, aspphi, asptheta, epq, :, sec, :, :]
            nrs = w.shape[-2] * w.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(w[..., 0, :], w[..., 1, :], w[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            w = self.w3dspace[vsw, aspphi, asptheta, epq, :, :, :, :]
            for i, s in enumerate(range(w.shape[-3])):
                nrs = w.shape[-2] * w.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(w[..., s, 0, :], w[..., s, 1, :], w[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax

    def plot_vspace(self, ax=None, aspphi=-1, asptheta=-1, epq=10, sec='all'):
        if ax == None:
            fig = plt.figure(figsize=(6, 6))
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('V-Space')
            # ax.set_title('W-Space')
            ax.set_xlim(-600, 600)
            ax.set_ylim(-600, 600)
            ax.set_zlim(-600, 600)
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            v = self.vspace[aspphi, asptheta, epq, :, sec, :, :]
            nrs = v.shape[-2] * v.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(v[..., 0, :], v[..., 1, :], v[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 600], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            v = self.vspace[aspphi, asptheta, epq, :, :, :, :]
            for i, s in enumerate(range(v.shape[-3])):
                nrs = v.shape[-2] * v.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(v[..., s, 0, :], v[..., s, 1, :], v[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 600], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax

    def plot_FoV(self, ax=None, aspphi=0, asptheta=0, sec='all'):
        if ax == None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection='3d')
            fig.canvas.set_window_title('FoV')
            # ax.set_title('FoV')
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
        colors = array([[77, 77, 0], [77, 57, 0], [77, 0, 0], [77, 0, 57], [38, 0, 77], [0, 38, 77], [0, 77, 77],
                        [0, 77, 19]])
        if isinstance(sec, int):
            f = self.FoV[aspphi, asptheta, :, sec, :, :]
            nrs = f.shape[-2] * f.shape[-1]
            shade_arr = linspace(0.1, 3.5, nrs)
            rgb = colors[sec]
            cc = zeros((nrs, 3))
            for j in range(nrs):
                cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
            ax.scatter(f[..., 0, :], f[..., 1, :], f[..., 2, :], c=cc)
            ax.scatter(0, 0, 0, c='k', s=5)
            ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        elif sec == 'all':
            f = self.FoV[aspphi, asptheta, :, :, :, :]
            for i, s in enumerate(range(f.shape[-3])):
                nrs = f.shape[-2] * f.shape[-1]
                shade_arr = linspace(0.1, 3.5, nrs)
                rgb = colors[i]
                cc = zeros((nrs, 3))
                for j in range(nrs):
                    cc[j] = lighten_color(rgb, factor=shade_arr[j]) / 255.
                ax.scatter(f[..., s, 0, :], f[..., s, 1, :], f[..., s, 2, :], c=cc)
                ax.scatter(0, 0, 0, c='k', s=5)
                ax.plot([0, 4], [0, 0], [0, 0], c='k', lw=0.8)
        else:
            print("no valid sector given")
        return ax


    def draw_sphere(self, ax = None, r = 1.):
        u, v = mgrid[0:2 * pi:20j, 0:pi:10j]
        x = r *cos(u) * sin(v)
        y = r* sin(u) * sin(v)
        z = r * cos(v)
        ax.plot_wireframe(x, y, z, color="r")

    def plot_pt(self, ax = None):
        x,y,z = self.vspace[0,6,0,0,0,:,-1]
        print(x,y,z)
        ax.scatter(x,y,z, s = 20, c = 'red')
